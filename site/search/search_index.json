{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Platform Engineering","text":"<p>Welcome to the University of Oregon's platform engineering reference site. Here you'll find self-paced modules, tool guides, and reference material for the tools and practices that power our infrastructure.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>New here? Start with Modules and work through them in order. Each module includes hands-on exercises designed to run on your own machine.</p> <p>Need to set up your environment? The Tools section has installation guides for Git, PDK, VS Code, and platform-specific setup like Homebrew (macOS) and WSL (Windows).</p>"},{"location":"#whats-here","title":"What's Here","text":"Section What You'll Find Modules Structured training: Git fundamentals, Puppet basics, advanced Puppet topics Tools Installation and configuration guides for development tools Concepts Background on infrastructure-as-code, version control, and related ideas Lab Guides Step-by-step instructions for hands-on exercises"},{"location":"#questions","title":"Questions?","text":"<p>Reach out to the platform engineering team if you get stuck or have suggestions for improving these materials.</p>"},{"location":"ai-disclaimer/","title":"AI Disclaimer","text":"<p>This disclaimer was 100% written by a Grug Brained Developer.</p>"},{"location":"ai-disclaimer/#why-have-this-page-lucass-responsible-ai-use-soapbox","title":"Why have this page? (Lucas's Responsible AI Use Soapbox)","text":"<p>As Uncle Ben once said, \"with great power comes great responsibility\". It's super easy nowadays to tell an AI to write the next great play that will rival Shakespeare. That AI will gleefully dump out a metric ton of seemingly good content. You read the first few paragraphs and think they sound great! Now, you want to get some peer feedback on your magnum opus, (or maybe you just want to humble brag that you coerced technology into making something totally novel), so you plop that baby into a Word doc and send it off to your friend.</p> <p>Ask yourself, \"How much time did it take me to write this, and how much time will it take them to review it? Did you just absolve yourself of the responsibility of ownership by saddling your friend with it instead?</p> <p>If you haven't read and approved, word for word, the entire content of whatever you're creating with AI, before sending it out to the folks who need it, you are the problem. Respect eachother's time. Friends don't let friends publish AI slop.</p> <p>Use AI as a tool, don't defer to it.</p>"},{"location":"ai-disclaimer/#why-are-you-yelling-at-me","title":"Why are you yelling at me?","text":"<p>As you can see from the above rant, I am not Claude, ChatGPT, or Gemini. I don't have perfect pacing or formatting, my words come out rambly and informal.</p> <p>This is good. This is human. This is the sign of someone who has created content with care and intent.</p> <p>This is evidence that the author was passionate enough to spend more time than expected trying to communicate this information in a relatable and captivating way.</p>"},{"location":"ai-disclaimer/#the-actual-reason-for-this-page","title":"The actual reason for this page","text":"<p>If you've read this far, it means that you probably care enough to know that this site (with the exception of this page) was mostly generated using AI (Claude specifically).</p> <p>However</p> <p>I have read every single byte of text that was placed in each file. I have made numerous manual edits so these materials aren't just another pile of slop. I hope that after reading this page, you understand why that matters, and I hope that you take my words to heart and practice responsible AI usage so that we can all live happily ever after.</p> <p>Thanks for coming to my TED Talk <code>&lt;3</code></p>"},{"location":"concepts/","title":"Concepts","text":"<p>Background reading on the ideas and practices that shape modern IT operations. These pages provide context and history\u2014no hands-on exercises, just the \"why\" behind how we work.</p>"},{"location":"concepts/#available-concepts","title":"Available Concepts","text":"Concept Description Infrastructure as Code Managing infrastructure through code instead of manual processes Version Control Tracking and managing changes to files over time"},{"location":"concepts/infrastructure-as-code/","title":"Infrastructure as Code","text":"<p>Infrastructure as Code (IaC) is the practice of managing and provisioning infrastructure through machine-readable definition files rather than manual processes or interactive configuration tools.</p>"},{"location":"concepts/infrastructure-as-code/#a-brief-history","title":"A Brief History","text":""},{"location":"concepts/infrastructure-as-code/#the-before-times-manual-administration","title":"The Before Times: Manual Administration","text":"<p>In the early days of system administration, every server was a unique snowflake. Administrators would SSH into machines, run commands, edit configuration files, and hope they remembered what they did. Documentation, if it existed at all, was a Word document or wiki page that was perpetually out of date.</p> <p>This worked when you had a handful of servers. A skilled admin could keep the state of a few dozen machines in their head, and recovering from problems meant drawing on experience and institutional knowledge.</p> <p>But this approach had fundamental problems:</p> <ul> <li>Configuration drift. Two servers that started identical would slowly diverge as administrators made one-off changes, applied patches at different times, or troubleshot issues in slightly different ways.</li> <li>The documentation gap. Written documentation required discipline to maintain and was almost always incomplete or outdated. The real documentation lived in people's heads.</li> <li>Knowledge silos. When experienced administrators left, their knowledge left with them. New team members faced archeological expeditions through undocumented systems.</li> <li>Unreliable recovery. Rebuilding a server from scratch meant remembering every manual step, every config file tweak, every package that was installed. In practice, this meant nobody wanted to rebuild anything.</li> </ul>"},{"location":"concepts/infrastructure-as-code/#the-rise-of-scripting","title":"The Rise of Scripting","text":"<p>The first response to these problems was scripting. Instead of typing commands interactively, administrators wrote shell scripts to automate common tasks. This was a significant improvement\u2014scripts could be saved, shared, and rerun.</p> <p>But scripts had limitations:</p> <ul> <li>Procedural thinking. Scripts describe how to do something, not what the end result should be. Run a script twice and you might get different results depending on the starting state.</li> <li>Error handling complexity. Making scripts robust against failures\u2014network timeouts, package conflicts, partial completions\u2014required significant effort.</li> <li>No built-in idempotency. If a script failed halfway through, running it again might duplicate work or fail in new ways.</li> </ul>"},{"location":"concepts/infrastructure-as-code/#configuration-management-emerges","title":"Configuration Management Emerges","text":"<p>In the mid-2000s, a new generation of tools emerged to address these limitations. CFEngine had existed since 1993, but tools like Puppet (2005), Chef (2009), and later Ansible (2012) and Salt (2011) brought configuration management to the mainstream.</p> <p>These tools introduced key concepts:</p> <ul> <li>Declarative configuration. Instead of describing steps, you describe the desired end state. \"This server should have nginx installed and running.\" The tool figures out how to get there.</li> <li>Idempotency. Apply the same configuration multiple times and you get the same result. If nginx is already installed and running, the tool does nothing.</li> <li>Convergence. Systems continuously move toward their defined state. If someone manually changes a configuration, the tool changes it back.</li> <li>Abstraction. High-level resources (packages, services, files) hide platform-specific details. The same configuration can work across different operating systems.</li> </ul>"},{"location":"concepts/infrastructure-as-code/#cloud-and-the-explosion-of-scale","title":"Cloud and the Explosion of Scale","text":"<p>The rise of cloud computing in the late 2000s and 2010s changed the game again. Suddenly, infrastructure wasn't just configuration\u2014it was the servers themselves. You could spin up hundreds of virtual machines with an API call.</p> <p>This drove the development of provisioning tools that extended IaC principles to infrastructure provisioning itself. Now you could define not just how servers should be configured, but what servers should exist, what networks they should be connected to, and what security policies should apply.</p> <p>The scale also forced a philosophical shift. When you have thousands of servers, you can't treat them as pets with names and individual care. They become cattle\u2014identical, replaceable, and disposable. If a server misbehaves, you don't debug it; you destroy it and spin up a new one.</p>"},{"location":"concepts/infrastructure-as-code/#core-principles","title":"Core Principles","text":""},{"location":"concepts/infrastructure-as-code/#declarative-over-procedural","title":"Declarative Over Procedural","text":"<p>The most important principle of IaC is declarative configuration. You describe what you want, not how to get there.</p> <p>Procedural approach (shell script):</p> <pre><code>if ! rpm -q nginx; then\n    yum install -y nginx\nfi\nif ! systemctl is-active nginx; then\n    systemctl start nginx\nfi\nif ! systemctl is-enabled nginx; then\n    systemctl enable nginx\nfi\n</code></pre> <p>Declarative approach (Puppet):</p> <pre><code>package { 'nginx':\n  ensure =&gt; installed,\n}\nservice { 'nginx':\n  ensure =&gt; running,\n  enable =&gt; true,\n}\n</code></pre> <p>The declarative version is shorter, but that's not the point. The point is that it describes the goal without encoding assumptions about the current state. The tool handles the logic of \"if not already installed, install it.\"</p>"},{"location":"concepts/infrastructure-as-code/#idempotency","title":"Idempotency","text":"<p>An operation is idempotent if applying it multiple times produces the same result as applying it once. This is crucial for IaC because configurations are applied repeatedly\u2014on schedule, after changes, during recovery.</p> <p>Idempotency means you can safely run your configuration management at any time without fear of side effects. If everything is already in the desired state, nothing happens. If something has drifted, it gets corrected.</p>"},{"location":"concepts/infrastructure-as-code/#version-control-as-the-source-of-truth","title":"Version Control as the Source of Truth","text":"<p>IaC without version control is incomplete. When infrastructure is defined in code, that code should live in a version control system like Git. This provides:</p> <ul> <li>History. Every change is recorded with who made it, when, and why.</li> <li>Auditability. You can trace any configuration back to the commit that introduced it.</li> <li>Rollback. Reverting to a previous state means reverting to a previous commit.</li> <li>Collaboration. Multiple people can work on infrastructure using branches and pull requests.</li> <li>Review. Changes can be reviewed before they're applied, catching problems early.</li> </ul> <p>The version control repository becomes the single source of truth. The question \"what should this server look like?\" is answered by the code in the repository, not by inspecting the server itself.</p>"},{"location":"concepts/infrastructure-as-code/#immutable-infrastructure","title":"Immutable Infrastructure","text":"<p>An evolution of IaC principles is immutable infrastructure\u2014the idea that servers should never be modified after they're created. Instead of updating a running server, you build a new image with the changes and replace the old server entirely.</p> <p>This approach:</p> <ul> <li>Eliminates configuration drift entirely</li> <li>Makes rollback trivial (deploy the previous image)</li> <li>Ensures development, staging, and production are truly identical</li> <li>Simplifies debugging (the server matches exactly what was tested)</li> </ul> <p>Immutable infrastructure is most practical in cloud environments where creating and destroying servers is fast and cheap. It's enabled by image-building tools and container technologies.</p>"},{"location":"concepts/infrastructure-as-code/#benefits-and-tradeoffs","title":"Benefits and Tradeoffs","text":""},{"location":"concepts/infrastructure-as-code/#benefits","title":"Benefits","text":"<p>Consistency. Every server built from the same code is identical. No more \"works on my machine\" or mysterious differences between environments.</p> <p>Speed. Provisioning a new server takes minutes instead of hours or days. Scaling up means running more instances of the same code.</p> <p>Reliability. Automated processes don't forget steps or make typos. Recovery from failures is faster because rebuilding is automated.</p> <p>Collaboration. Infrastructure changes go through the same review processes as application code. Knowledge is captured in code, not trapped in individuals' heads.</p> <p>Compliance. IaC provides an audit trail of every change. You can prove that systems are configured according to policy because the policy is encoded in version-controlled code.</p>"},{"location":"concepts/infrastructure-as-code/#tradeoffs","title":"Tradeoffs","text":"<p>Learning curve. IaC tools have their own languages, concepts, and best practices. Teams need time to build expertise.</p> <p>Upfront investment. Writing good IaC takes longer than making a quick manual change. The payoff comes with scale and over time.</p> <p>Complexity. IaC adds layers of abstraction. When something goes wrong, you need to understand both the infrastructure and the tools managing it.</p> <p>State management. Some IaC tools maintain state files that must be carefully managed. State drift or corruption can cause serious problems.</p> <p>Not everything fits. Some infrastructure components\u2014legacy systems, one-off configurations, vendor appliances\u2014may not fit neatly into IaC models.</p>"},{"location":"concepts/infrastructure-as-code/#cultural-implications","title":"Cultural Implications","text":"<p>IaC isn't just a technical practice; it's a cultural shift. It requires thinking about infrastructure differently:</p> <ul> <li>Servers are disposable. Don't fix a broken server; replace it with a new one built from code.</li> <li>Changes go through process. No more SSH-ing in to make a quick fix. Changes go through version control and review.</li> <li>Documentation is code. The authoritative description of your infrastructure is the code that builds it.</li> <li>Everyone can contribute. When infrastructure is code, developers can propose infrastructure changes using the same tools they use for application code.</li> </ul> <p>This cultural shift can be challenging. Experienced administrators may resist losing direct access to systems. Processes slow down when every change needs a pull request. But organizations that embrace these changes find their infrastructure becomes more reliable, more scalable, and more understandable over time.</p>"},{"location":"concepts/version-control/","title":"Version Control","text":"<p>Version control is the practice of tracking and managing changes to files over time. It lets you record the history of a project, collaborate with others without overwriting each other's work, and return to any previous state when something goes wrong.</p>"},{"location":"concepts/version-control/#a-brief-history","title":"A Brief History","text":""},{"location":"concepts/version-control/#the-original-version-control-filenames","title":"The Original Version Control: Filenames","text":"<p>Before version control systems existed, people tracked changes the obvious way: copying files and renaming them.</p> <pre><code>report.doc\nreport_v2.doc\nreport_v2_final.doc\nreport_v2_final_FINAL.doc\nreport_v2_final_FINAL_reviewed.doc\n</code></pre> <p>This approach has obvious problems. Which file is actually current? What changed between versions? Who made which changes? What if two people edit different \"final\" copies and need to combine their work?</p> <p>For solo work on simple documents, filename versioning sort of works. For anything involving collaboration, multiple files, or the need to understand what changed over time, it falls apart quickly.</p>"},{"location":"concepts/version-control/#local-version-control","title":"Local Version Control","text":"<p>The first generation of version control systems solved the \"which version is current\" problem by automating the process of saving snapshots. Tools like RCS (Revision Control System, 1982) stored a history of changes in a local database. You could check out a file, edit it, and check it back in with a description of what changed.</p> <p>RCS tracked individual files, storing each version as a delta\u2014just the differences from the previous version. This was efficient for storage and let you see the history of any single file. But it had significant limitations:</p> <ul> <li>Single-user focus. RCS locked files during editing. Only one person could work on a file at a time.</li> <li>File-level tracking. Projects are made of related files, but RCS tracked each file independently. There was no concept of \"the state of the project at a point in time.\"</li> <li>Local only. The version history lived on one machine. No built-in way to share or synchronize with others.</li> </ul>"},{"location":"concepts/version-control/#centralized-version-control","title":"Centralized Version Control","text":"<p>The next generation addressed collaboration by introducing a central server. Systems like CVS (Concurrent Versions System, 1990) and later Subversion (SVN, 2000) stored the version history on a server that everyone connected to.</p> <p>This model introduced important concepts:</p> <ul> <li>Repository. A central location storing the complete history of a project.</li> <li>Working copy. A local checkout of files that you edit. Changes are committed back to the repository.</li> <li>Concurrent editing. Multiple people could work on the same files simultaneously. The system would merge changes or flag conflicts.</li> <li>Project-level commits. Changes to multiple files could be committed together as a single logical unit.</li> </ul> <p>Centralized systems made collaborative software development practical. Teams could work together on the same codebase, track who changed what, and maintain a shared history. Subversion in particular became the dominant version control system in the 2000s.</p> <p>But centralized systems had their own limitations:</p> <ul> <li>Network dependency. Most operations required a connection to the central server. Committing, viewing history, comparing versions\u2014all needed network access.</li> <li>Single point of failure. If the server went down, nobody could commit or access history. If the server was lost without backups, the history was gone.</li> <li>Branching pain. Branches were technically possible but often discouraged because merging was difficult and error-prone.</li> <li>Commit friction. Because commits went directly to the shared server, developers tended to make fewer, larger commits. Work in progress stayed local and untracked.</li> </ul>"},{"location":"concepts/version-control/#distributed-version-control","title":"Distributed Version Control","text":"<p>The current generation of version control systems\u2014Git (2005), Mercurial (2005), and others\u2014took a fundamentally different approach: distribution.</p> <p>In a distributed system, every developer has a complete copy of the repository, including the full history. You don't check out a working copy from a server; you clone the entire repository to your machine. Commits are local operations. Synchronizing with others is a separate step.</p> <p>This architecture has profound implications:</p> <ul> <li>Speed. Almost everything is local. Commits, diffs, history browsing, branch creation\u2014all happen instantly without network round trips.</li> <li>Offline capability. You can work, commit, branch, and explore history without any network connection. Synchronize when convenient.</li> <li>No single point of failure. Every clone is a full backup. If any server dies, any clone can restore it.</li> <li>Cheap branching. Branches are lightweight local operations. Creating a branch takes milliseconds. This changes how people work\u2014branches become a routine tool rather than a heavyweight process.</li> <li>Flexible workflows. There's no mandated central server. Teams can organize however they want: central repository, multiple repositories, peer-to-peer, hierarchical review chains.</li> </ul> <p>Git emerged from the Linux kernel development community after a dispute with their previous version control provider. Linus Torvalds designed it for the specific needs of a large, distributed open source project: speed, data integrity, and support for non-linear development with thousands of parallel branches.</p> <p>Git won. By the mid-2010s, it had become the dominant version control system across the software industry. The rise of GitHub (2008) accelerated this by adding a social layer\u2014pull requests, issues, profiles\u2014that made collaboration easier and more visible.</p>"},{"location":"concepts/version-control/#core-concepts","title":"Core Concepts","text":""},{"location":"concepts/version-control/#snapshots-not-diffs","title":"Snapshots, Not Diffs","text":"<p>Some version control systems store changes as a series of diffs\u2014the differences between each version and the next. Git takes a different approach: each commit is a snapshot of the entire project at that moment in time.</p> <p>This might sound inefficient, but Git is clever about storage. Unchanged files aren't duplicated; Git just points to the previous version. And for storage efficiency, Git periodically packs objects and stores deltas. But conceptually, each commit represents a complete picture of the project.</p> <p>This snapshot model makes certain operations much simpler. Switching between branches or commits means loading a different snapshot, not replaying a series of patches. Comparing any two points in history is straightforward\u2014you're comparing two snapshots, not computing the cumulative effect of all changes between them.</p>"},{"location":"concepts/version-control/#the-three-states","title":"The Three States","text":"<p>In Git, files exist in one of three states:</p> <ul> <li>Modified. You've changed the file but haven't recorded the change yet.</li> <li>Staged. You've marked a modified file to go into your next commit.</li> <li>Committed. The change is safely stored in your local repository.</li> </ul> <p>This three-stage process might seem unnecessarily complex compared to a simple \"save\" operation. But the staging area gives you control over exactly what goes into each commit. You might have five modified files, but only three of them are related to the bug you're fixing. Stage those three, commit them as a logical unit, then deal with the other two separately.</p> <p>Clean, focused commits make history easier to understand and problems easier to diagnose. The staging area is the mechanism that makes this practical.</p>"},{"location":"concepts/version-control/#commits-and-the-dag","title":"Commits and the DAG","text":"<p>Each commit in Git records:</p> <ul> <li>A snapshot of all tracked files</li> <li>A pointer to the parent commit(s)</li> <li>Author and committer information</li> <li>A timestamp</li> <li>A commit message</li> </ul> <p>Commits are identified by a SHA-1 hash\u2014a 40-character string computed from the commit's contents. This hash is essentially a fingerprint: any change to the commit (content, message, parent, anything) would produce a different hash.</p> <p>The parent pointers create a directed acyclic graph (DAG) of commits. Most commits have one parent\u2014the commit that came before. Merge commits have two parents\u2014the commits from each branch being combined. The first commit in a repository has no parent.</p> <p>This graph structure is fundamental to how Git works. Branches are just pointers to commits. The history of a branch is the chain of commits you can reach by following parent pointers. Merging combines histories by creating a commit with multiple parents.</p>"},{"location":"concepts/version-control/#branches-are-cheap","title":"Branches Are Cheap","text":"<p>In older systems, creating a branch might copy files, take significant time, and create pressure to avoid branching unnecessarily. In Git, a branch is literally a 41-byte file containing a commit hash.</p> <p>Creating a branch is instantaneous. Switching between branches is fast. Having dozens of branches costs almost nothing. This changes how you work.</p> <p>In a world where branches are expensive, you work on the main line and branch only when necessary\u2014for releases, for risky experiments. Merging is infrequent and often painful.</p> <p>In a world where branches are cheap, you branch constantly. Every feature, every bug fix, every experiment gets its own branch. You work in isolation until ready, then merge back. The main branch stays stable because incomplete work lives elsewhere.</p> <p>This model\u2014often called \"feature branching\" or \"topic branching\"\u2014has become the standard workflow for software development. It's practical only because Git makes branching nearly free.</p>"},{"location":"concepts/version-control/#why-version-control-matters","title":"Why Version Control Matters","text":""},{"location":"concepts/version-control/#history-as-documentation","title":"History as Documentation","text":"<p>Every commit is a record: what changed, who changed it, when, and why (if the commit message is good). This history is invaluable for understanding a system.</p> <p>When you encounter confusing code, you can trace its history. When did it appear? Who wrote it? What was the commit message? Is there an associated issue or pull request with discussion? Often the \"why\" that's missing from the code itself is preserved in the version control history.</p> <p>This historical record also serves compliance and audit needs. In regulated industries, being able to demonstrate who changed what and when is a requirement. Version control provides this automatically.</p>"},{"location":"concepts/version-control/#fearless-experimentation","title":"Fearless Experimentation","text":"<p>Without version control, changing working code is risky. What if you break something? What if you can't get back to the working state? This fear leads to stagnation\u2014code that nobody wants to touch because it might break.</p> <p>Version control eliminates this fear. You can always get back to any previous state. Try something radical; if it doesn't work, revert. Create a branch for an experiment; if it fails, delete it. The safety net of version control enables the experimentation that leads to better code.</p>"},{"location":"concepts/version-control/#collaboration-without-chaos","title":"Collaboration Without Chaos","text":"<p>Software projects involve multiple people changing the same codebase. Without coordination, this leads to chaos\u2014people overwriting each other's work, changes getting lost, incompatible modifications creating bugs.</p> <p>Version control provides the coordination. It tracks who changed what. It merges concurrent changes automatically when possible and flags conflicts when not. It provides a shared history that everyone can reference.</p> <p>This coordination scales. Small teams can work together easily. Large open source projects with thousands of contributors across the globe function because version control manages the complexity.</p>"},{"location":"concepts/version-control/#the-foundation-for-automation","title":"The Foundation for Automation","text":"<p>Version control is the foundation for modern software development practices:</p> <ul> <li>Continuous integration triggers automated builds and tests when code is pushed.</li> <li>Code review happens on pull requests before changes merge.</li> <li>Deployment pipelines deploy code from specific branches or tags.</li> <li>Infrastructure as code stores configuration in version control and applies it automatically.</li> </ul> <p>None of these practices would be practical without version control as the underlying mechanism for tracking and triggering on changes.</p>"},{"location":"concepts/version-control/#the-social-dimension","title":"The Social Dimension","text":"<p>The rise of platforms like GitHub added a social layer to version control that changed how people work and collaborate.</p>"},{"location":"concepts/version-control/#pull-requests-and-code-review","title":"Pull Requests and Code Review","text":"<p>A pull request (or merge request) is a proposal to merge changes from one branch into another. But it's more than just a merge mechanism\u2014it's a collaboration tool.</p> <p>Pull requests provide a place for discussion. Reviewers can comment on specific lines of code. Authors can respond and make changes. The conversation is preserved alongside the code, providing context for future readers.</p> <p>Code review has become standard practice not because tools forced it, but because pull requests made it natural. The barrier to reviewing code dropped, and the benefits became obvious.</p>"},{"location":"concepts/version-control/#open-source-collaboration","title":"Open Source Collaboration","text":"<p>Distributed version control made large-scale open source collaboration practical. Anyone can clone a repository, make changes, and propose them back. Maintainers can review and merge contributions from strangers without giving them direct access.</p> <p>This model\u2014fork, modify, propose\u2014has enabled an explosion of open source software. Projects can accept contributions from thousands of developers without security concerns or coordination overhead.</p>"},{"location":"concepts/version-control/#profiles-and-portfolios","title":"Profiles and Portfolios","text":"<p>Version control history is public on platforms like GitHub. Your contributions are visible: what projects you've worked on, how much you've contributed, the quality of your commits and pull requests.</p> <p>For developers, this visibility serves as a portfolio. For employers, it's a signal about candidates. For projects, it's a measure of contributor reputation.</p> <p>This visibility cuts both ways. Good work is rewarded with reputation. But the pressure to show activity can lead to gaming metrics or feeling inadequate compared to those with more public contributions.</p>"},{"location":"concepts/version-control/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"concepts/version-control/#meaningless-commit-messages","title":"Meaningless Commit Messages","text":"<p>The commit message is your chance to explain why a change was made. Messages like \"fix bug,\" \"update code,\" or \"WIP\" waste this opportunity. When someone (including future you) needs to understand the change, a meaningless message provides no help.</p> <p>Good commit messages describe intent, not just action. Not \"change timeout to 30\" but \"increase timeout to handle slow network responses.\" The diff shows what changed; the message should explain why.</p>"},{"location":"concepts/version-control/#commits-that-are-too-large","title":"Commits That Are Too Large","text":"<p>A commit that changes dozens of files across multiple unrelated features is hard to understand, hard to review, and hard to revert if something goes wrong.</p> <p>Smaller, focused commits are easier to work with. Each commit should represent a single logical change. If you need to explain your commit with \"and,\" it might be too big.</p>"},{"location":"concepts/version-control/#ignoring-history","title":"Ignoring History","text":"<p>Version control captures history, but that history is only useful if you reference it. Many developers never run <code>git log</code>, never use <code>git blame</code>, never explore how the code evolved.</p> <p>The history is a resource. When debugging, check when the problematic code was introduced. When reviewing code, look at the history of the file. When onboarding, explore the commit history to understand how the project developed.</p>"},{"location":"concepts/version-control/#fear-of-branching","title":"Fear of Branching","text":"<p>Developers coming from centralized systems sometimes avoid branches out of habit. They commit directly to main, or they accumulate large changes locally before committing.</p> <p>In Git, branches are cheap and merging usually works well. Use them freely. Branch for features, for experiments, for anything you're not sure about. The cost is near zero; the benefits are significant.</p>"},{"location":"concepts/version-control/#version-control-beyond-code","title":"Version Control Beyond Code","text":"<p>Version control originated in software development, but the principles apply anywhere you're managing changing files:</p> <ul> <li>Documentation benefits from version control. Technical writers can track changes, collaborate on drafts, and maintain multiple versions for different releases.</li> <li>Configuration files for infrastructure should be version controlled. This is the foundation of infrastructure as code.</li> <li>Data science workflows can track experiments, parameters, and notebooks. Specialized tools extend Git for large data files.</li> <li>Legal documents go through revisions. Version control can track changes more precisely than Word's track changes.</li> <li>Writing projects of any kind can benefit from the ability to experiment freely and maintain history.</li> </ul> <p>The core insight\u2014that tracking changes over time is valuable\u2014applies far beyond code. As version control tools become more accessible, these practices spread to new domains.</p>"},{"location":"modules/","title":"Modules","text":"<p>Self-paced learning for platform engineering tools and practices. Each module includes hands-on exercises you can complete on your own machine.</p>"},{"location":"modules/#available-modules","title":"Available Modules","text":"Module Description Prerequisites Git Version control fundamentals\u2014commits, branches, merges, remotes None Puppet Puppet fundamentals None Puppet - Advanced Advanced Puppet topics Puppet, Git"},{"location":"modules/#how-to-use-these-modules","title":"How to Use These Modules","text":"<ol> <li>Check prerequisites. Each module lists required tools and prior modules. Install what you need before starting.</li> <li>Work through sections in order. Concepts build on each other.</li> <li>Use a scratch environment. Create throwaway repos and VMs so you can experiment freely.</li> <li>Break things on purpose. The best way to learn recovery is to need it.</li> </ol>"},{"location":"modules/#tools-reference","title":"Tools Reference","text":"<p>Not sure how to install something? Check the Tools section for installation guides and configuration tips.</p>"},{"location":"modules/git/00-index/","title":"Git 101","text":"<p>You've probably been there: a config file that worked yesterday is broken today, and nobody knows what changed. Or you're afraid to touch a script because there's no way to undo it. Or you're emailing files back and forth with <code>-v2-final-FINAL.txt</code> in the name.</p> <p>Git solves these problems. It tracks every change you make, who made it, and why, so you can experiment freely, collaborate without stepping on each other, and always get back to a known-good state.</p>"},{"location":"modules/git/00-index/#why-you-should-care","title":"Why You Should Care","text":"<p>If you manage configs, scripts, documentation, or infrastructure-as-code, Git gives you:</p> <ul> <li>A real undo button. Made a bad change? Roll back to any previous version in seconds.</li> <li>Fearless experimentation. Try risky changes on a branch. If it works, merge it. If not, delete it. Your main copy stays safe.</li> <li>Accountability without blame. When something breaks at 2 AM, <code>git log</code> and <code>git blame</code> tell you exactly what changed and when, so you can fix it instead of guessing.</li> <li>Collaboration that scales. Multiple people can work on the same files without overwriting each other's work.</li> </ul>"},{"location":"modules/git/00-index/#lessons","title":"Lessons","text":"<p>Work through these in order:</p> <ol> <li>Local Foundations: Set up Git, create a repo, make your first commits, ignore files you don't want tracked</li> <li>Understanding History: Read logs, compare changes, find who changed what</li> <li>Branching and Merging: Work on isolated changes and combine them safely</li> <li>Working with Remotes: Sync with shared repositories (push, pull, clone)</li> <li>Collaboration: Pull requests, code review, and team workflows</li> <li>Recovery and Confidence: Fix mistakes and get unstuck</li> <li>Branching Strategies (advanced): Git Flow, GitHub Flow, and trunk-based development</li> </ol>"},{"location":"modules/git/00-index/#tips-for-success","title":"Tips for Success","text":"<ul> <li>Use a scratch repo. Create a throwaway folder to experiment in. Break things on purpose. Delete it and start over when you get stuck. That's the fastest way to learn.</li> <li>Run <code>git status</code> constantly. Before and after every operation. It tells you exactly what Git sees, and it's the quickest way to stay oriented.</li> <li>Don't memorize, understand. Git has a lot of commands, but they all revolve around a few core concepts. Once those click, the commands make sense.</li> </ul>"},{"location":"modules/git/00-index/#a-note-on-gits-evolving-commands","title":"A Note on Git's Evolving Commands","text":"<p>Git has been around since 2005, and its command set has evolved over time. Some older commands do multiple unrelated things, while newer commands split those responsibilities apart.</p> <p>For example, <code>git checkout</code> historically did two very different jobs: switching branches and restoring files. This was confusing, so Git introduced <code>git switch</code> (for branches) and <code>git restore</code> (for files) to make intentions clearer. Both the old and new commands work, but you'll see different ones in different tutorials.</p> <p>Some common examples:</p> Old way New way What it does <code>git checkout branch-name</code> <code>git switch branch-name</code> Switch branches <code>git checkout -b new-branch</code> <code>git switch -c new-branch</code> Create and switch to branch <code>git checkout -- file.txt</code> <code>git restore file.txt</code> Discard uncommitted changes <code>git reset HEAD file.txt</code> <code>git restore --staged file.txt</code> Unstage a file <p>When you're reading Stack Overflow answers or older documentation, you'll encounter the older syntax. It still works fine. This guide generally uses the newer commands where they exist, but points out the old way so you recognize it in the wild.</p>"},{"location":"modules/git/00-prerequisites/","title":"Prerequisites","text":""},{"location":"modules/git/00-prerequisites/#required-tools","title":"Required Tools","text":"Tool Why You Need It Terminal You'll run all Git commands here. macOS/Linux: use the built-in terminal. Windows: use WSL. Git The version control system this module teaches"},{"location":"modules/git/00-prerequisites/#recommended-tools","title":"Recommended Tools","text":"Tool Why It Helps Visual Studio Code Makes merge conflicts much easier to resolve with its built-in diff viewer"},{"location":"modules/git/00-prerequisites/#required-modules","title":"Required Modules","text":"<p>None. This is a foundational module.</p>"},{"location":"modules/git/01-local-foundations/","title":"Local Foundations","text":"<p>By the end of this section, you'll have Git configured, a repository created, your first commits under your belt, and a <code>.gitignore</code> keeping unwanted files out of version control.</p>"},{"location":"modules/git/01-local-foundations/#configure-your-identity","title":"Configure Your Identity","text":"<p>Before you make any commits, Git needs to know who you are. This information appears in every commit you make (it's how your team knows who changed what).</p> <p>If you haven't already, complete the Initial Configuration steps in the Git tool guide. This sets your name and email globally so you don't have to configure it for each repository.</p> <p>Global vs Local Config</p> <p>The <code>--global</code> flag sets these values for all repositories on your machine. You can override them per-repository by running the same commands without <code>--global</code> from inside a repo.</p>"},{"location":"modules/git/01-local-foundations/#create-your-first-repository","title":"Create Your First Repository","text":"<p>Let's create a scratch repository you can experiment with freely.</p> <pre><code>mkdir -p ~/scratch/git-sandbox\ncd ~/scratch/git-sandbox\n</code></pre> <p>Now initialize Git:</p> <pre><code>git init\n</code></pre> <p>You'll see: <code>Initialized empty Git repository in .../git-sandbox/.git/</code></p> <p>That <code>.git</code> folder is where Git stores everything (your history, branches, and metadata). You might never need to touch it directly, but knowing it exists helps demystify what Git is doing.</p> <p>Run your first status check:</p> <pre><code>git status\n</code></pre> <p>You'll see something like:</p> <pre><code>On branch main\n\nNo commits yet\n\nnothing to commit (create/copy some files and use \"git add\" to track)\n</code></pre> <p>This tells you three things:</p> <ol> <li>You're on a branch called <code>main</code> (we'll cover branches later)</li> <li>There are no commits yet</li> <li>There's nothing to commit because the folder is empty</li> </ol>"},{"location":"modules/git/01-local-foundations/#the-stage-and-commit-workflow","title":"The Stage and Commit Workflow","text":"<p>Here's where Git differs from simple backup systems. Git doesn't automatically track every file or save every change. You explicitly tell it what to record. This happens in two steps:</p> <ol> <li>Stage: Select which changes you want to include in your next commit</li> <li>Commit: Save those staged changes as a permanent snapshot</li> </ol> <p>Think of it like packing a box before shipping it. You don't throw everything in at once. You choose what goes in the box (staging), then seal and label it (commit).</p>"},{"location":"modules/git/01-local-foundations/#create-a-file-and-check-status","title":"Create a file and check status","text":"<pre><code>echo \"# Server Notes\" &gt; notes.md\ngit status\n</code></pre> <p>Git now shows <code>notes.md</code> as an \"untracked file.\" Git sees it exists but isn't tracking changes to it yet.</p> <pre><code>Untracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n    notes.md\n</code></pre>"},{"location":"modules/git/01-local-foundations/#stage-the-file","title":"Stage the file","text":"<pre><code>git add notes.md\ngit status\n</code></pre> <p>Now <code>notes.md</code> appears under \"Changes to be committed.\" It's staged, ready to be included in your next commit.</p> <pre><code>Changes to be committed:\n  (use \"git rm --cached &lt;file&gt;...\" to unstage)\n    new file:   notes.md\n</code></pre> <p>Stage multiple files at once</p> <p><code>git add .</code> stages all changes in the current directory. Useful, but be careful: make sure you're not staging files you don't want (like secrets or build artifacts). Always run <code>git status</code> first.</p>"},{"location":"modules/git/01-local-foundations/#commit-the-staged-changes","title":"Commit the staged changes","text":"<pre><code>git commit -m \"Add server notes file\"\n</code></pre> <p>Done. You've created your first commit. Git responds with a summary:</p> <pre><code>[main (root-commit) a1b2c3d] Add server notes file\n 1 file changed, 1 insertion(+)\n create mode 100644 notes.md\n</code></pre> <p>The string <code>a1b2c3d</code> is an abbreviated commit hash (a unique identifier for this exact snapshot). Every commit gets one.</p>"},{"location":"modules/git/01-local-foundations/#the-full-cycle","title":"The full cycle","text":"<p>Let's do it again to reinforce the pattern. Edit the file:</p> <pre><code>echo \"Reboot procedure: sudo reboot\" &gt;&gt; notes.md\n</code></pre> <p>Check what changed:</p> <pre><code>git status\n</code></pre> <p>Git shows <code>notes.md</code> as \"modified.\" It's already tracked, so Git notices the change, but that change isn't staged yet.</p> <p>See exactly what changed:</p> <pre><code>git diff\n</code></pre> <p>This shows the lines added (prefixed with <code>+</code>) and removed (prefixed with <code>-</code>). Get comfortable with <code>git diff</code>. It's your preview before committing.</p> <p>Stage and commit:</p> <pre><code>git add notes.md\ngit commit -m \"Add reboot procedure to server notes\"\n</code></pre>"},{"location":"modules/git/01-local-foundations/#why-two-steps","title":"Why two steps?","text":"<p>The staging area lets you craft clean, logical commits even when your working directory is messy. You might have three files changed, but only two are related to the same task. Stage those two, commit them, then stage and commit the third separately.</p> <p>Clean commits make history easier to read and problems easier to diagnose. When something breaks, you want to find \"Add SSL config\" in your history, not \"Various changes and fixes.\"</p>"},{"location":"modules/git/01-local-foundations/#writing-good-commit-messages","title":"Writing Good Commit Messages","text":"<p>Commit messages are for your future self and your teammates. Write them like you'll be the one debugging this at 2 AM six months from now.</p>"},{"location":"modules/git/01-local-foundations/#use-imperative-mood","title":"Use imperative mood","text":"<p>Write messages as commands: \"Add config file\" not \"Added config file\" or \"Adding config file.\"</p> <p>This matches Git's own conventions (e.g., \"Merge branch 'feature'\") and reads naturally when you look at history: \"If I apply this commit, it will Add config file.\"</p> <p>Good:</p> <ul> <li><code>Add SSL certificate rotation script</code></li> <li><code>Fix incorrect timeout in backup job</code></li> <li><code>Remove deprecated API endpoint</code></li> </ul> <p>Bad:</p> <ul> <li><code>Added some stuff</code></li> <li><code>WIP</code></li> <li><code>asdfasdf</code></li> <li><code>Fixed it</code></li> </ul>"},{"location":"modules/git/01-local-foundations/#be-specific","title":"Be specific","text":"<p>Your message should explain what changed and, briefly, why. Someone reading the log should understand the intent without reading the code.</p> Instead of... Write... <code>Update config</code> <code>Increase nginx worker connections to 4096</code> <code>Fix bug</code> <code>Fix race condition in session cleanup</code> <code>Changes</code> <code>Add retry logic to LDAP connection</code>"},{"location":"modules/git/01-local-foundations/#keep-the-first-line-short","title":"Keep the first line short","text":"<p>The first line should be under 50 characters (this is what appears in logs, GitHub, and most Git tools). If you need more detail, add a blank line and then a longer description:</p> <pre><code>git commit -m \"Add retry logic to LDAP connection\n\nPrevious implementation failed silently on network timeouts.\nNow retries 3 times with exponential backoff before failing.\"\n</code></pre>"},{"location":"modules/git/01-local-foundations/#ignoring-files-with-gitignore","title":"Ignoring Files with .gitignore","text":"<p>Not everything belongs in version control. Secrets, build artifacts, editor configs, and OS clutter should stay out of your repository. In real projects, you'll want to set this up before your first commit, but for learning, it helps to understand staging and commits first.</p>"},{"location":"modules/git/01-local-foundations/#create-a-gitignore-file","title":"Create a .gitignore file","text":"<p>In your repository root, create a file named <code>.gitignore</code>:</p> <pre><code>echo \"*.log\" &gt; .gitignore\necho \".DS_Store\" &gt;&gt; .gitignore\necho \"*.tmp\" &gt;&gt; .gitignore\n</code></pre> <p>Now create a file that matches one of these patterns:</p> <pre><code>echo \"debug output\" &gt; debug.log\ngit status\n</code></pre> <p>Git doesn't show <code>debug.log</code> as untracked. It's ignored.</p> <p>But <code>.gitignore</code> itself should be committed (it's part of your project's configuration):</p> <pre><code>git add .gitignore\ngit commit -m \"Add gitignore for logs and temp files\"\n</code></pre>"},{"location":"modules/git/01-local-foundations/#common-patterns","title":"Common patterns","text":"<p><code>.gitignore</code> uses glob patterns:</p> <pre><code># Ignore all .log files\n*.log\n\n# Ignore the entire build directory\nbuild/\n\n# Ignore .env files (secrets!)\n.env\n.env.local\n\n# Ignore OS clutter\n.DS_Store\nThumbs.db\n\n# Ignore editor/IDE directories\n.idea/\n.vscode/\n*.swp\n\n# Ignore a specific file\nconfig/secrets.yaml\n\n# But don't ignore this specific file (override previous pattern)\n!config/example-secrets.yaml\n</code></pre> <p>The <code>!</code> prefix negates a pattern (useful when you want to ignore a directory but keep one file inside it).</p>"},{"location":"modules/git/01-local-foundations/#what-to-ignore","title":"What to ignore","text":"<p>For infrastructure and ops work, you'll commonly ignore:</p> Category Examples Secrets <code>.env</code>, <code>*.pem</code>, <code>*credentials*</code>, <code>secrets.yaml</code> Logs <code>*.log</code>, <code>logs/</code> Build output <code>build/</code>, <code>dist/</code>, <code>*.pyc</code>, <code>__pycache__/</code> OS files <code>.DS_Store</code>, <code>Thumbs.db</code> Editor files <code>.idea/</code>, <code>.vscode/</code>, <code>*.swp</code> Dependencies <code>node_modules/</code>, <code>.venv/</code>, <code>vendor/</code> <p>Secrets already committed</p> <p><code>.gitignore</code> only prevents future tracking. If you've already committed a secret, it's in your history forever (until you rewrite history, which is advanced and messy). Always set up <code>.gitignore</code> early, and double-check before your first commit.</p>"},{"location":"modules/git/01-local-foundations/#global-gitignore","title":"Global gitignore","text":"<p>Some ignores apply to every repository on your machine (like <code>.DS_Store</code> on macOS or editor swap files). Instead of adding these to every project, set a global ignore file:</p> <pre><code>git config --global core.excludesfile ~/.gitignore_global\n</code></pre> <p>Then create <code>~/.gitignore_global</code> with your personal ignores. These apply everywhere without cluttering project-specific <code>.gitignore</code> files.</p>"},{"location":"modules/git/01-local-foundations/#exercises","title":"Exercises","text":"<ol> <li> <p>Practice the cycle: Create two more files in your sandbox, stage them separately, and commit each with a descriptive message. Run <code>git status</code> before and after each command to see how the state changes.</p> </li> <li> <p>Selective staging: Modify two files, but only stage and commit one. Verify the other file still shows as modified after the commit.</p> </li> <li> <p>Set up gitignore: Create a <code>.gitignore</code> that ignores <code>*.log</code> files and any file named <code>secrets.txt</code>. Test it by creating files that match these patterns and verifying they don't appear in <code>git status</code>.</p> </li> <li> <p>View your history: Run <code>git log</code> to see your commits. Try <code>git log --oneline</code> for a compact view. We'll dig deeper into history in the next section.</p> </li> </ol>"},{"location":"modules/git/02-understanding-history/","title":"Understanding History","text":"<p>By the end of this section, you'll know how to navigate your repository's history, compare versions, and track down exactly who changed what and when.</p>"},{"location":"modules/git/02-understanding-history/#reading-the-commit-log","title":"Reading the Commit Log","text":"<p>Your commit history is more than a backup. It's a searchable record of every decision you've made. Learning to read it quickly is one of the most useful Git skills.</p>"},{"location":"modules/git/02-understanding-history/#basic-log","title":"Basic log","text":"<p>From your sandbox repository (or any Git repo), run:</p> <pre><code>git log\n</code></pre> <p>You'll see something like:</p> <pre><code>commit 8f3a2b1c9d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a\nAuthor: Your Name &lt;you@example.com&gt;\nDate:   Mon Jan 15 14:32:01 2024 -0800\n\n    Add reboot procedure to server notes\n\ncommit a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0\nAuthor: Your Name &lt;you@example.com&gt;\nDate:   Mon Jan 15 14:30:45 2024 -0800\n\n    Add server notes file\n</code></pre> <p>Each entry shows:</p> <ul> <li>Commit hash: The full 40-character unique identifier</li> <li>Author: Who made the commit (from your Git config)</li> <li>Date: When it was committed</li> <li>Message: What you wrote with <code>-m</code></li> </ul> <p>Press <code>q</code> to exit the log viewer.</p>"},{"location":"modules/git/02-understanding-history/#compact-view-with-oneline","title":"Compact view with --oneline","text":"<p>For a quick overview:</p> <pre><code>git log --oneline\n</code></pre> <pre><code>8f3a2b1 Add reboot procedure to server notes\na1b2c3d Add server notes file\n</code></pre> <p>This shows just the abbreviated hash and the first line of each message. Much faster to scan when you have hundreds of commits.</p>"},{"location":"modules/git/02-understanding-history/#filtering-the-log","title":"Filtering the log","text":"<p>Real repositories have thousands of commits. These flags help you find what you need:</p> <pre><code># Last 5 commits\ngit log -5\n\n# Commits from the past week\ngit log --since=\"1 week ago\"\n\n# Commits by a specific author\ngit log --author=\"lcrown\"\n\n# Commits that changed a specific file\ngit log -- notes.md\n\n# Search commit messages for a keyword\ngit log --grep=\"reboot\"\n</code></pre> <p>You can combine these. To find commits by \"lcrown\" in the last month that mention \"ssl\":</p> <pre><code>git log --author=\"lcrown\" --since=\"1 month ago\" --grep=\"ssl\"\n</code></pre>"},{"location":"modules/git/02-understanding-history/#visualizing-branches","title":"Visualizing branches","text":"<p>Once you start working with branches (next section), this becomes invaluable:</p> <pre><code>git log --oneline --graph --all\n</code></pre> <p>The <code>--graph</code> flag draws ASCII art showing how branches split and merge. The <code>--all</code> flag includes all branches, not just the one you're on.</p>"},{"location":"modules/git/02-understanding-history/#comparing-changes-with-diff","title":"Comparing Changes with Diff","text":"<p>You used <code>git diff</code> briefly in the last section. Let's go deeper. It's one of Git's most powerful tools for understanding what actually changed.</p>"},{"location":"modules/git/02-understanding-history/#working-directory-vs-staged","title":"Working directory vs staged","text":"<p>When you modify files, <code>git diff</code> shows unstaged changes:</p> <pre><code>echo \"New line\" &gt;&gt; notes.md\ngit diff\n</code></pre> <pre><code>diff --git a/notes.md b/notes.md\nindex 3b18e51..f4a3c92 100644\n--- a/notes.md\n+++ b/notes.md\n@@ -1,2 +1,3 @@\n # Server Notes\n Reboot procedure: sudo reboot\n+New line\n</code></pre> <p>Lines starting with <code>+</code> are additions. Lines starting with <code>-</code> are deletions. The <code>@@</code> line tells you where in the file the change occurred.</p> <p>After staging:</p> <pre><code>git add notes.md\ngit diff\n</code></pre> <p>You'll see nothing. <code>git diff</code> with no arguments only shows unstaged changes. To see what's staged:</p> <pre><code>git diff --staged\n</code></pre> <p>Now you see the changes again. This distinction matters when you're selectively staging parts of your work.</p>"},{"location":"modules/git/02-understanding-history/#comparing-commits","title":"Comparing commits","text":"<p>Compare any two commits by their hashes:</p> <pre><code>git diff a1b2c3d 8f3a2b1\n</code></pre> <p>Or compare against a previous commit using <code>~</code> notation:</p> <pre><code># Current HEAD vs one commit ago\ngit diff HEAD~1\n\n# Current HEAD vs three commits ago\ngit diff HEAD~3\n</code></pre> <p><code>HEAD</code> always refers to your current commit. <code>HEAD~1</code> means \"one commit before HEAD.\"</p>"},{"location":"modules/git/02-understanding-history/#diff-specific-files","title":"Diff specific files","text":"<p>When a commit touches many files but you only care about one:</p> <pre><code>git diff HEAD~1 -- notes.md\n</code></pre> <p>The <code>--</code> separates the commit references from the file paths.</p>"},{"location":"modules/git/02-understanding-history/#stat-view-for-overview","title":"Stat view for overview","text":"<p>When you want to see which files changed without the full diff:</p> <pre><code>git diff --stat HEAD~3\n</code></pre> <pre><code> notes.md     | 2 ++\n config.yaml  | 5 ++---\n 2 files changed, 4 insertions(+), 3 deletions(-)\n</code></pre> <p>This shows files changed and a rough sense of how much.</p>"},{"location":"modules/git/02-understanding-history/#finding-who-changed-what","title":"Finding Who Changed What","text":"<p>When something breaks (or when you want to understand why code looks the way it does), Git can tell you exactly who changed each line and when.</p>"},{"location":"modules/git/02-understanding-history/#git-blame","title":"git blame","text":"<p>This command shows the commit, author, and date for every line in a file:</p> <pre><code>git blame notes.md\n</code></pre> <pre><code>a1b2c3d4 (Your Name 2024-01-15 14:30:45 -0800 1) # Server Notes\n8f3a2b1c (Your Name 2024-01-15 14:32:01 -0800 2) Reboot procedure: sudo reboot\n</code></pre> <p>Each line shows:</p> <ul> <li>Abbreviated commit hash</li> <li>Author</li> <li>Date and time</li> <li>Line number</li> <li>The actual content</li> </ul> <p>Despite the name, <code>git blame</code> isn't about assigning blame. It's about understanding context. When you find a strange line of code, blame tells you which commit introduced it so you can read the commit message and understand why.</p>"},{"location":"modules/git/02-understanding-history/#blame-a-specific-range","title":"Blame a specific range","text":"<p>For long files, you can limit blame to specific lines:</p> <pre><code># Lines 10-20 only\ngit blame -L 10,20 config.yaml\n</code></pre>"},{"location":"modules/git/02-understanding-history/#git-show","title":"git show","text":"<p>Once blame tells you which commit changed a line, <code>git show</code> gives you the full picture:</p> <pre><code>git show 8f3a2b1\n</code></pre> <p>This displays:</p> <ul> <li>The full commit message</li> <li>The author and date</li> <li>The complete diff of all changes in that commit</li> </ul> <p>It's the natural follow-up to blame: \"This line was changed in commit X\" \u2192 \"What else changed in commit X, and why?\"</p>"},{"location":"modules/git/02-understanding-history/#git-log-for-a-file","title":"git log for a file","text":"<p>To see the full history of changes to a specific file:</p> <pre><code>git log -- notes.md\n</code></pre> <p>Add <code>-p</code> to see the actual diffs in each commit:</p> <pre><code>git log -p -- notes.md\n</code></pre> <p>This is useful when you want to understand how a file evolved over time.</p>"},{"location":"modules/git/02-understanding-history/#exercises","title":"Exercises","text":"<p>These exercises use your sandbox repository. If you don't have one, revisit the Local Foundations section to create it.</p> <ol> <li> <p>Explore the log: Run <code>git log</code>, <code>git log --oneline</code>, and <code>git log --oneline --graph</code>. If your sandbox only has a few commits, that's fine. The point is getting comfortable with the commands.</p> </li> <li> <p>Practice diff: Modify <code>notes.md</code>, then run <code>git diff</code>. Stage the changes and run <code>git diff</code> again (notice it's empty). Run <code>git diff --staged</code> to see the staged changes. Commit when you're done.</p> </li> <li> <p>Use blame: Run <code>git blame notes.md</code> and pick a commit hash from the output. Run <code>git show &lt;hash&gt;</code> to see the full commit.</p> </li> <li> <p>Search history: Add a few more commits with different messages. Then use <code>git log --grep</code> to find commits containing a specific word from one of your messages.</p> </li> </ol>"},{"location":"modules/git/03-branching-and-merging/","title":"Branching and Merging","text":"<p>By the end of this section, you'll understand how to work on isolated changes without affecting your main code, and how to combine those changes back together when they're ready.</p>"},{"location":"modules/git/03-branching-and-merging/#why-branches-exist","title":"Why Branches Exist","text":"<p>So far, all your commits have been on a single line of history. That works fine when you're the only person working on something simple. But what happens when you want to:</p> <ul> <li>Try a risky change without breaking what already works?</li> <li>Work on two different features at the same time?</li> <li>Let multiple people work on the same codebase without stepping on each other?</li> </ul> <p>Branches solve all of these. A branch is just a pointer to a commit, and you can have as many as you want. When you create a new branch, you're saying \"I want to start a separate line of work from this point.\" Your main branch stays safe while you experiment.</p> <p>Think of it like making a copy of a document before editing it. Except Git does this efficiently (it doesn't actually copy all the files), and it gives you powerful tools to merge your changes back later.</p>"},{"location":"modules/git/03-branching-and-merging/#creating-and-switching-branches","title":"Creating and Switching Branches","text":""},{"location":"modules/git/03-branching-and-merging/#see-your-current-branch","title":"See your current branch","text":"<p>You've actually been on a branch this whole time. Check which one:</p> <pre><code>git branch\n</code></pre> <pre><code>* main\n</code></pre> <p>The <code>*</code> marks your current branch. Right now, <code>main</code> is probably your only branch.</p>"},{"location":"modules/git/03-branching-and-merging/#create-a-new-branch","title":"Create a new branch","text":"<p>Let's create a branch to add a new feature to your notes:</p> <pre><code>git branch add-backup-notes\n</code></pre> <p>Now list branches again:</p> <pre><code>git branch\n</code></pre> <pre><code>  add-backup-notes\n* main\n</code></pre> <p>You've created the branch, but you're still on <code>main</code> (note the <code>*</code>).</p>"},{"location":"modules/git/03-branching-and-merging/#switch-to-the-new-branch","title":"Switch to the new branch","text":"<pre><code>git checkout add-backup-notes\n</code></pre> <pre><code>Switched to branch 'add-backup-notes'\n</code></pre> <p>Now <code>git branch</code> shows:</p> <pre><code>* add-backup-notes\n  main\n</code></pre> <p>Create and switch in one command</p> <p><code>git checkout -b branch-name</code> creates a new branch and switches to it immediately. This is what you'll use most of the time.</p>"},{"location":"modules/git/03-branching-and-merging/#make-changes-on-the-branch","title":"Make changes on the branch","text":"<p>Now any commits you make will only affect this branch. Let's add some content:</p> <pre><code>echo \"## Backup Procedures\" &gt;&gt; notes.md\necho \"Daily: rsync to backup server\" &gt;&gt; notes.md\ngit add notes.md\ngit commit -m \"Add backup procedures section\"\n</code></pre> <p>Check your history:</p> <pre><code>git log --oneline\n</code></pre> <p>You'll see your new commit at the top. But here's the key insight: this commit only exists on <code>add-backup-notes</code>. Switch back to <code>main</code> and look:</p> <pre><code>git checkout main\ngit log --oneline\n</code></pre> <p>Your \"Add backup procedures section\" commit isn't there. Check the file:</p> <pre><code>cat notes.md\n</code></pre> <p>The backup procedures aren't there either. They're safely isolated on your feature branch.</p>"},{"location":"modules/git/03-branching-and-merging/#the-shortcut-git-switch","title":"The shortcut: git switch","text":"<p>Git added <code>git switch</code> as a clearer alternative to <code>git checkout</code> for branch operations:</p> <pre><code>git switch add-backup-notes    # switch to existing branch\ngit switch -c new-branch       # create and switch (like checkout -b)\n</code></pre> <p>Both <code>checkout</code> and <code>switch</code> work. Use whichever you prefer, but know that <code>checkout</code> does other things too (like restoring files), while <code>switch</code> is only for branches.</p>"},{"location":"modules/git/03-branching-and-merging/#merging-branches","title":"Merging Branches","text":"<p>Once your feature is ready, you'll want to merge it back into <code>main</code>.</p>"},{"location":"modules/git/03-branching-and-merging/#fast-forward-merge","title":"Fast-forward merge","text":"<p>The simplest case is when <code>main</code> hasn't changed since you branched. Git can just move <code>main</code> forward to include your new commits.</p> <p>Make sure you're on <code>main</code>:</p> <pre><code>git checkout main\n</code></pre> <p>Now merge your feature branch:</p> <pre><code>git merge add-backup-notes\n</code></pre> <pre><code>Updating a1b2c3d..f5e6d7c\nFast-forward\n notes.md | 2 ++\n 1 file changed, 2 insertions(+)\n</code></pre> <p>\"Fast-forward\" means Git just moved the <code>main</code> pointer forward. No merge commit needed.</p> <p>Check your log:</p> <pre><code>git log --oneline\n</code></pre> <p>Your backup procedures commit is now part of <code>main</code>.</p>"},{"location":"modules/git/03-branching-and-merging/#three-way-merge","title":"Three-way merge","text":"<p>Fast-forward only works when the target branch hasn't changed. When both branches have new commits, Git performs a three-way merge and creates a merge commit.</p> <p>Let's set up that scenario. First, create and switch to a new branch:</p> <pre><code>git checkout -b add-monitoring-notes\necho \"## Monitoring\" &gt;&gt; notes.md\necho \"Check Nagios dashboard hourly\" &gt;&gt; notes.md\ngit add notes.md\ngit commit -m \"Add monitoring section\"\n</code></pre> <p>Now switch back to <code>main</code> and make a different change:</p> <pre><code>git checkout main\necho \"## Contact Info\" &gt;&gt; notes.md\necho \"On-call: ops@example.com\" &gt;&gt; notes.md\ngit add notes.md\ngit commit -m \"Add contact info section\"\n</code></pre> <p>Now <code>main</code> and <code>add-monitoring-notes</code> have diverged (both have commits the other doesn't). Merge the feature branch:</p> <pre><code>git merge add-monitoring-notes\n</code></pre> <p>Git opens your editor to write a merge commit message. The default message (usually \"Merge branch 'add-monitoring-notes'\") is fine. Save and close.</p> <p>Check the graph view:</p> <pre><code>git log --oneline --graph\n</code></pre> <pre><code>*   8c9d0e1 Merge branch 'add-monitoring-notes'\n|\\\n| * 4a5b6c7 Add monitoring section\n* | 7d8e9f0 Add contact info section\n|/\n* f5e6d7c Add backup procedures section\n* ...\n</code></pre> <p>You can see where the branches diverged and came back together.</p>"},{"location":"modules/git/03-branching-and-merging/#delete-merged-branches","title":"Delete merged branches","text":"<p>After merging, you don't need the feature branch anymore:</p> <pre><code>git branch -d add-backup-notes\ngit branch -d add-monitoring-notes\n</code></pre> <p>The <code>-d</code> flag only works if the branch has been merged. This prevents you from accidentally deleting unmerged work. (Use <code>-D</code> to force-delete an unmerged branch, but be careful.)</p>"},{"location":"modules/git/03-branching-and-merging/#handling-merge-conflicts","title":"Handling Merge Conflicts","text":"<p>Merge conflicts happen when both branches changed the same part of the same file. Git can't automatically decide which version to keep, so it asks you to resolve it manually.</p>"},{"location":"modules/git/03-branching-and-merging/#create-a-conflict","title":"Create a conflict","text":"<p>Let's intentionally create one. Start a new branch:</p> <pre><code>git checkout -b update-contact\n</code></pre> <p>Edit the contact info (change it to something different):</p> <pre><code># Using sed to replace the email\nsed -i '' 's/ops@example.com/oncall@example.com/' notes.md\ngit add notes.md\ngit commit -m \"Update contact email to oncall address\"\n</code></pre> <p>Now switch to <code>main</code> and make a conflicting change to the same line:</p> <pre><code>git checkout main\nsed -i '' 's/ops@example.com/support@example.com/' notes.md\ngit add notes.md\ngit commit -m \"Update contact email to support address\"\n</code></pre> <p>Both branches changed the same line differently. Try to merge:</p> <pre><code>git merge update-contact\n</code></pre> <pre><code>Auto-merging notes.md\nCONFLICT (content): Merge conflict in notes.md\nAutomatic merge failed; fix conflicts and then commit the result.\n</code></pre>"},{"location":"modules/git/03-branching-and-merging/#understand-the-conflict-markers","title":"Understand the conflict markers","text":"<p>Open <code>notes.md</code>. You'll see something like:</p> <pre><code>## Contact Info\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\nOn-call: support@example.com\n=======\nOn-call: oncall@example.com\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; update-contact\n</code></pre> <p>The markers show:</p> <ul> <li><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> to <code>=======</code>: The version on your current branch (main)</li> <li><code>=======</code> to <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; update-contact</code>: The version on the branch you're merging</li> </ul>"},{"location":"modules/git/03-branching-and-merging/#resolve-the-conflict","title":"Resolve the conflict","text":"<p>Edit the file to keep the version you want (or combine them). Remove the conflict markers entirely. For example, if you decide <code>oncall@example.com</code> is correct:</p> <pre><code>## Contact Info\nOn-call: oncall@example.com\n</code></pre> <p>Or maybe you want both:</p> <pre><code>## Contact Info\nOn-call: oncall@example.com\nSupport: support@example.com\n</code></pre> <p>After editing, stage and commit:</p> <pre><code>git add notes.md\ngit commit -m \"Merge update-contact, keep oncall email\"\n</code></pre> <p>The merge is complete.</p>"},{"location":"modules/git/03-branching-and-merging/#check-status-during-conflicts","title":"Check status during conflicts","text":"<p>If you get lost during a conflict, <code>git status</code> tells you exactly what's happening:</p> <pre><code>git status\n</code></pre> <pre><code>On branch main\nYou have unmerged paths.\n  (fix conflicts and run \"git commit\")\n  (use \"git merge --abort\" to abort the merge)\n\nUnmerged paths:\n  (use \"git add &lt;file&gt;...\" to mark resolution)\n    both modified:   notes.md\n</code></pre> <p>Abort if needed</p> <p>If you get into a messy conflict and want to start over, run <code>git merge --abort</code>. This cancels the merge and returns your branch to its pre-merge state.</p>"},{"location":"modules/git/03-branching-and-merging/#when-to-branch","title":"When to Branch","text":"<p>Branch by default. In professional workflows, <code>main</code> represents stable, reviewed code. Committing directly to it should be the exception, not the rule.</p> <p>Creating a branch takes seconds. Even for small changes, the habit of branching pays off because it builds muscle memory for when it really matters. More importantly, branches enable code review through pull requests, where teammates can catch issues before they reach <code>main</code>.</p>"},{"location":"modules/git/03-branching-and-merging/#when-committing-directly-to-main-is-acceptable","title":"When committing directly to main is acceptable","text":"Scenario Why it's okay Fixing a typo you just introduced You're immediately correcting your own recent mistake True emergencies when you're the only responder Speed matters, but document what you did afterward <p>For personal projects with no collaborators, the stakes are lower, but branching is still good practice.</p> <p>Team policies vary</p> <p>Many teams protect <code>main</code> entirely, requiring all changes to go through pull requests. Even if your team doesn't enforce this, treating <code>main</code> as protected builds good habits. For more on how teams structure their branching workflows, see Branching Strategies.</p>"},{"location":"modules/git/03-branching-and-merging/#branch-naming-conventions","title":"Branch naming conventions","text":"<p>Good branch names describe what you're working on:</p> <pre><code>add-ssl-rotation\nfix-backup-timeout\nupdate-nginx-config\n</code></pre> <p>Some teams use prefixes to categorize work:</p> <pre><code>feature/add-ssl-rotation\nbugfix/backup-timeout\nhotfix/critical-security-patch\n</code></pre> <p>Pick a convention and stick with it. The name should tell someone what to expect without reading the code.</p>"},{"location":"modules/git/03-branching-and-merging/#exercises","title":"Exercises","text":"<p>These exercises use your sandbox repository.</p> <ol> <li> <p>Create and merge a branch: Create a branch called <code>add-troubleshooting</code>, add a \"Troubleshooting\" section to <code>notes.md</code> with a few tips, commit it, switch to <code>main</code>, and merge. Verify the content appears on <code>main</code>.</p> </li> <li> <p>Practice the graph view: After the merge, run <code>git log --oneline --graph --all</code>. Identify where your branch was created and where it merged back.</p> </li> <li> <p>Create a conflict on purpose: Create two branches from <code>main</code>. On each branch, edit the same line of the same file differently. Merge one branch to <code>main</code> successfully, then try to merge the second. Resolve the conflict.</p> </li> <li> <p>Explore branch cleanup: Run <code>git branch</code> to see all your branches. Delete any that have been merged using <code>git branch -d</code>.</p> </li> <li> <p>Try git switch: If you've been using <code>git checkout</code>, try the equivalent commands with <code>git switch</code>. Switch between branches and create a new one with <code>git switch -c</code>.</p> </li> </ol>"},{"location":"modules/git/04-working-with-remotes/","title":"Working with Remotes","text":"<p>By the end of this section, you'll know how to sync your local repository with shared repositories using clone, push, pull, and fetch.</p>"},{"location":"modules/git/04-working-with-remotes/#what-is-a-remote","title":"What Is a Remote?","text":"<p>So far, everything you've done has been local. Your repository lives on your machine, and no one else can see it. A remote is a copy of your repository hosted somewhere else (usually a server like GitHub, GitLab, or Bitbucket).</p> <p>Remotes enable:</p> <ul> <li>Backup. Your code exists somewhere other than your laptop.</li> <li>Collaboration. Others can access the same repository.</li> <li>Deployment. Many workflows deploy directly from a remote repository.</li> </ul> <p>When you clone a repository, Git automatically names the remote <code>origin</code>. You can have multiple remotes, but most workflows only use one.</p>"},{"location":"modules/git/04-working-with-remotes/#see-your-remotes","title":"See your remotes","text":"<pre><code>git remote -v\n</code></pre> <p>If you created your repository locally with <code>git init</code>, you won't have any remotes yet. If you cloned from somewhere, you'll see:</p> <pre><code>origin  https://github.com/username/repo.git (fetch)\norigin  https://github.com/username/repo.git (push)\n</code></pre>"},{"location":"modules/git/04-working-with-remotes/#add-a-remote","title":"Add a remote","text":"<p>If you started locally and want to connect to a remote:</p> <pre><code>git remote add origin https://github.com/username/repo.git\n</code></pre> <p>Now <code>origin</code> points to that URL. You can push your local commits there.</p>"},{"location":"modules/git/04-working-with-remotes/#cloning-a-repository","title":"Cloning a Repository","text":"<p>Cloning downloads a complete copy of a remote repository to your machine, including all history.</p>"},{"location":"modules/git/04-working-with-remotes/#clone-with-ssh-recommended","title":"Clone with SSH (recommended)","text":"<pre><code>git clone git@github.com:username/repo.git\n</code></pre> <p>SSH is the preferred method for regular Git use. Once you've set up SSH keys with your Git host, you never need to enter credentials. Pushes and pulls just work.</p> <p>If you haven't set up SSH keys yet, it's worth the few minutes of setup. GitHub, GitLab, and Bitbucket all have guides for adding your SSH key to your account.</p> <p>Set up SSH keys once, benefit forever</p> <p>SSH keys are more secure than passwords and eliminate credential prompts entirely. If you're going to use Git regularly, take the time to set this up. Your future self will thank you.</p>"},{"location":"modules/git/04-working-with-remotes/#clone-with-https","title":"Clone with HTTPS","text":"<pre><code>git clone https://github.com/username/repo.git\n</code></pre> <p>HTTPS works without any setup, which makes it fine for quick one-off clones. However, you'll need to enter credentials (or configure a credential helper) for push operations. For repositories you'll work with frequently, SSH is worth the initial setup.</p> <p>When you clone, Git automatically:</p> <ul> <li>Downloads all commits and branches</li> <li>Sets up <code>origin</code> pointing to the URL you cloned from</li> <li>Checks out the default branch (usually <code>main</code>)</li> </ul>"},{"location":"modules/git/04-working-with-remotes/#clone-into-a-specific-folder","title":"Clone into a specific folder","text":"<pre><code>git clone https://github.com/username/repo.git my-folder-name\n</code></pre>"},{"location":"modules/git/04-working-with-remotes/#clone-a-specific-branch","title":"Clone a specific branch","text":"<p>By default, clone checks out the default branch. To start on a different branch:</p> <pre><code>git clone -b develop https://github.com/username/repo.git\n</code></pre>"},{"location":"modules/git/04-working-with-remotes/#push-pull-and-fetch","title":"Push, Pull, and Fetch","text":"<p>These three commands handle synchronization between your local repository and the remote.</p>"},{"location":"modules/git/04-working-with-remotes/#git-push-send-your-commits-to-the-remote","title":"git push: send your commits to the remote","text":"<p>After committing locally, push sends those commits to the remote:</p> <pre><code>git push origin main\n</code></pre> <p>This pushes your <code>main</code> branch to the <code>origin</code> remote. If you're on <code>main</code> and it's configured to track <code>origin/main</code> (which clone sets up automatically), you can just run:</p> <pre><code>git push\n</code></pre>"},{"location":"modules/git/04-working-with-remotes/#first-push-of-a-new-branch","title":"First push of a new branch","text":"<p>If you created a branch locally and want to push it to the remote for the first time:</p> <pre><code>git push -u origin my-new-branch\n</code></pre> <p>The <code>-u</code> flag (short for <code>--set-upstream</code>) tells Git to track this remote branch. After that, plain <code>git push</code> and <code>git pull</code> work without specifying the branch.</p>"},{"location":"modules/git/04-working-with-remotes/#push-rejected","title":"Push rejected?","text":"<p>If someone else pushed commits since you last pulled, Git rejects your push:</p> <pre><code>! [rejected]        main -&gt; main (fetch first)\nerror: failed to push some refs to 'origin'\nhint: Updates were rejected because the remote contains work that you do not\nhint: have locally.\n</code></pre> <p>This is Git protecting you from overwriting others' work. Pull first, then push.</p>"},{"location":"modules/git/04-working-with-remotes/#git-pull-get-commits-from-the-remote-and-merge","title":"git pull: get commits from the remote and merge","text":"<p>Pull downloads new commits from the remote and merges them into your current branch:</p> <pre><code>git pull\n</code></pre> <p>This is actually two operations combined:</p> <ol> <li><code>git fetch</code> (download new commits)</li> <li><code>git merge</code> (merge them into your branch)</li> </ol> <p>If there are no conflicts, Git merges automatically. If there are conflicts, you'll need to resolve them just like any other merge (see Branching and Merging).</p>"},{"location":"modules/git/04-working-with-remotes/#pull-with-rebase","title":"Pull with rebase","text":"<p>Some teams prefer rebasing instead of merging when pulling:</p> <pre><code>git pull --rebase\n</code></pre> <p>Instead of creating a merge commit, this replays your local commits on top of the remote commits. The result is a linear history without merge commits cluttering your log every time you sync.</p> <p>The tradeoff: Rebase rewrites your local commit hashes. This is fine for commits that only exist on your machine, but you should understand what's happening. Some developers find the cleaner history worth it; others prefer seeing the true merge history.</p> <p>If your team uses rebase-based pulls, you can set it as the default:</p> <pre><code>git config --global pull.rebase true\n</code></pre> <p>With this set, <code>git pull</code> automatically rebases instead of merging. You can override it with <code>git pull --no-rebase</code> when needed.</p> <p>Follow your team's convention</p> <p>Whether to use merge or rebase when pulling is a team decision. If you're joining an existing project, look at the commit history to see what convention they follow, or ask.</p>"},{"location":"modules/git/04-working-with-remotes/#git-fetch-download-without-merging","title":"git fetch: download without merging","text":"<p>Fetch downloads new commits from the remote but doesn't merge them:</p> <pre><code>git fetch origin\n</code></pre> <p>This updates your knowledge of what's on the remote (stored in <code>origin/main</code>, <code>origin/develop</code>, etc.) without changing your working directory. Useful when you want to see what's changed before deciding what to do.</p> <p>After fetching, you can:</p> <pre><code># See what's new on the remote\ngit log main..origin/main\n\n# See the diff\ngit diff main origin/main\n\n# Merge when ready\ngit merge origin/main\n</code></pre> <p>Fetch is the safe way to check what's happening on the remote without committing to a merge.</p> <p>In practice, most people just use <code>git pull</code> for daily work. Fetch is useful when you want to inspect changes before merging, or when you're troubleshooting a conflict and want to understand what's on the remote first.</p>"},{"location":"modules/git/04-working-with-remotes/#working-with-branches-on-remotes","title":"Working with Branches on Remotes","text":""},{"location":"modules/git/04-working-with-remotes/#see-all-branches-local-and-remote","title":"See all branches (local and remote)","text":"<pre><code>git branch -a\n</code></pre> <p>Remote branches appear as <code>remotes/origin/branch-name</code>.</p>"},{"location":"modules/git/04-working-with-remotes/#check-out-a-remote-branch","title":"Check out a remote branch","text":"<p>If someone else created a branch and pushed it, fetch first, then check it out:</p> <pre><code>git fetch origin\ngit checkout feature-branch\n</code></pre> <p>Git automatically creates a local branch that tracks the remote one.</p>"},{"location":"modules/git/04-working-with-remotes/#delete-a-remote-branch","title":"Delete a remote branch","text":"<p>After merging a branch, clean it up on the remote:</p> <pre><code>git push origin --delete feature-branch\n</code></pre>"},{"location":"modules/git/04-working-with-remotes/#common-scenarios","title":"Common Scenarios","text":""},{"location":"modules/git/04-working-with-remotes/#i-cloned-a-repo-but-want-to-push-to-my-own-copy","title":"\"I cloned a repo but want to push to my own copy\"","text":"<p>You cloned someone else's repository but want your own remote (common when starting from a template):</p> <pre><code># Remove the original remote\ngit remote remove origin\n\n# Add your own\ngit remote add origin https://github.com/your-username/your-repo.git\n\n# Push\ngit push -u origin main\n</code></pre>"},{"location":"modules/git/04-working-with-remotes/#i-need-to-see-what-changed-on-the-remote","title":"\"I need to see what changed on the remote\"","text":"<pre><code>git fetch origin\ngit log HEAD..origin/main --oneline\n</code></pre> <p>This shows commits on the remote that you don't have locally.</p>"},{"location":"modules/git/04-working-with-remotes/#someone-elses-push-broke-my-pull","title":"\"Someone else's push broke my pull\"","text":"<p>If <code>git pull</code> fails because of conflicts with changes you weren't expecting:</p> <pre><code># Abort the merge\ngit merge --abort\n\n# Fetch and look at what changed\ngit fetch origin\ngit log main..origin/main\ngit diff main origin/main\n\n# When you understand the changes, try the merge again\ngit merge origin/main\n</code></pre>"},{"location":"modules/git/04-working-with-remotes/#exercises","title":"Exercises","text":"<ol> <li> <p>Clone a repository: Find a public repository on GitHub and clone it. Run <code>git remote -v</code> to see the remote configuration. Run <code>git log --oneline -10</code> to see recent history.</p> </li> <li> <p>Practice the pull workflow: If you have a repository with a remote, make a change on GitHub's web interface (edit a README), then pull the change locally.</p> </li> <li> <p>Explore fetch: Run <code>git fetch origin</code>, then compare your local branch to the remote with <code>git log main..origin/main</code>. See what's different before merging.</p> </li> <li> <p>Push a new branch: Create a local branch, make a commit, and push it with <code>git push -u origin branch-name</code>. Verify it appears on the remote.</p> </li> <li> <p>Clean up a remote branch: After pushing a test branch, delete it with <code>git push origin --delete branch-name</code>. Verify it's gone on the remote.</p> </li> </ol>"},{"location":"modules/git/04-working-with-remotes/#next-steps","title":"Next Steps","text":"<p>Now that you know the mechanics of working with remotes, see Collaboration for team workflows, pull requests, and best practices for working with others.</p>"},{"location":"modules/git/05-collaboration/","title":"Collaboration","text":"<p>By the end of this section, you'll know how to work effectively with others on a shared repository, including the pull request workflow and best practices for keeping your team's codebase healthy.</p>"},{"location":"modules/git/05-collaboration/#working-on-a-team","title":"Working on a Team","text":"<p>When you're working alone, you can commit whenever and however you want. On a team, your habits affect everyone. Good collaboration practices prevent conflicts, keep history readable, and make code review effective.</p>"},{"location":"modules/git/05-collaboration/#daily-habits","title":"Daily Habits","text":"<p>These habits prevent most collaboration problems before they start.</p>"},{"location":"modules/git/05-collaboration/#pull-before-you-start-working","title":"Pull before you start working","text":"<p>At the beginning of each work session:</p> <pre><code>git checkout main\ngit pull\n</code></pre> <p>This ensures you're starting from the latest code. Many merge conflicts happen because someone started work on an outdated branch.</p>"},{"location":"modules/git/05-collaboration/#work-on-branches-not-main","title":"Work on branches, not main","text":"<p>Even for small changes, create a branch:</p> <pre><code>git checkout -b fix-config-typo\n</code></pre> <p>This keeps <code>main</code> clean and makes code review possible. See Branching and Merging for details.</p>"},{"location":"modules/git/05-collaboration/#keep-branches-short-lived","title":"Keep branches short-lived","text":"<p>The longer your branch lives, the more it diverges from <code>main</code>, and the harder it becomes to merge. Aim to merge branches within a few days.</p> <p>If you're working on something larger, regularly merge <code>main</code> into your branch to stay current:</p> <pre><code>git checkout my-feature\ngit merge main\n</code></pre>"},{"location":"modules/git/05-collaboration/#pull-before-you-push","title":"Pull before you push","text":"<p>Before pushing, pull to get any changes others have made:</p> <pre><code>git pull\ngit push\n</code></pre> <p>If there are conflicts, resolve them locally rather than forcing your changes over others'.</p>"},{"location":"modules/git/05-collaboration/#the-pull-request-workflow","title":"The Pull Request Workflow","text":"<p>Pull requests (PRs) are how most teams review and merge code. Instead of pushing directly to <code>main</code>, you push a branch and ask others to review it.</p>"},{"location":"modules/git/05-collaboration/#the-basic-flow","title":"The basic flow","text":"<p>Step 1: Create a branch and make your changes</p> <pre><code>git checkout -b add-logging\n# ... make commits ...\n</code></pre> <p>Step 2: Push your branch to the remote</p> <pre><code>git push -u origin add-logging\n</code></pre> <p>Step 3: Open a pull request</p> <p>On GitHub, GitLab, or Bitbucket, navigate to your repository and click \"New Pull Request\" (or similar). Select your branch and the target branch (usually <code>main</code>).</p> <p>Step 4: Write a good PR description</p> <ul> <li>Summarize what the change does and why</li> <li>Link to any related issues or tickets</li> <li>Note anything reviewers should pay attention to</li> <li>Include testing instructions if applicable</li> </ul> <p>Step 5: Address review feedback</p> <p>Reviewers may request changes. Make additional commits on your branch and push them:</p> <pre><code># Make requested changes\ngit add .\ngit commit -m \"Address review feedback\"\ngit push\n</code></pre> <p>The PR updates automatically.</p> <p>Step 6: Merge when approved</p> <p>Once reviewers approve, merge the PR (usually via the web interface). Most teams delete the branch after merging.</p>"},{"location":"modules/git/05-collaboration/#keeping-your-pr-up-to-date","title":"Keeping your PR up to date","text":"<p>If <code>main</code> changes while your PR is open, you may need to update your branch:</p> <pre><code>git checkout my-feature\ngit fetch origin\ngit merge origin/main\n# Resolve any conflicts\ngit push\n</code></pre> <p>Some teams prefer rebasing:</p> <pre><code>git checkout my-feature\ngit fetch origin\ngit rebase origin/main\n# Resolve any conflicts\ngit push --force-with-lease\n</code></pre> <p>The <code>--force-with-lease</code> flag is safer than <code>--force</code> because it fails if someone else pushed to your branch.</p>"},{"location":"modules/git/05-collaboration/#squashing-commits","title":"Squashing Commits","text":"<p>When you're working on a feature, you might make many small commits: \"WIP\", \"fix typo\", \"actually fix it this time\". These are useful while working but clutter the history when merged.</p> <p>Squashing combines multiple commits into one clean commit.</p>"},{"location":"modules/git/05-collaboration/#why-squash","title":"Why squash?","text":"<ul> <li>Cleaner history. <code>main</code> shows one commit per feature, not dozens of work-in-progress commits.</li> <li>Easier reverts. If something breaks, you can revert one commit instead of hunting through many.</li> <li>Better blame. <code>git blame</code> shows meaningful commits, not \"fix typo\".</li> </ul>"},{"location":"modules/git/05-collaboration/#squash-when-merging-easiest","title":"Squash when merging (easiest)","text":"<p>Most Git hosts offer a \"Squash and merge\" button when merging PRs. This combines all commits in your branch into one commit on <code>main</code>. You write a new commit message summarizing the change.</p> <p>This is the easiest approach and doesn't require any local Git commands.</p>"},{"location":"modules/git/05-collaboration/#squash-locally-before-pushing","title":"Squash locally before pushing","text":"<p>If you want to squash before opening the PR (or if your team requires it), use interactive rebase.</p> <p>Say you have four commits on your branch:</p> <pre><code>git log --oneline -4\n</code></pre> <pre><code>d4e5f6g Fix typo in error message\nc3d4e5f Add error handling\nb2c3d4e Add logging function\na1b2c3d Initial implementation\n</code></pre> <p>To squash these into one commit:</p> <pre><code>git rebase -i HEAD~4\n</code></pre> <p>Git opens your editor:</p> <pre><code>pick a1b2c3d Initial implementation\npick b2c3d4e Add logging function\npick c3d4e5f Add error handling\npick d4e5f6g Fix typo in error message\n</code></pre> <p>Change <code>pick</code> to <code>squash</code> (or <code>s</code>) for all commits except the first:</p> <pre><code>pick a1b2c3d Initial implementation\nsquash b2c3d4e Add logging function\nsquash c3d4e5f Add error handling\nsquash d4e5f6g Fix typo in error message\n</code></pre> <p>Save and close. Git opens another editor for you to write the combined commit message. Write something descriptive:</p> <pre><code>Add logging with error handling\n\n- Implement logging function\n- Add error handling for edge cases\n- Include meaningful error messages\n</code></pre> <p>Save, and your four commits are now one.</p>"},{"location":"modules/git/05-collaboration/#push-after-squashing","title":"Push after squashing","text":"<p>If you've already pushed the branch, you'll need to force push after squashing:</p> <pre><code>git push --force-with-lease\n</code></pre> <p>Only squash your own branches</p> <p>Squashing rewrites history. Only do this on branches that are exclusively yours. Never squash commits that others have based work on.</p>"},{"location":"modules/git/05-collaboration/#code-review-best-practices","title":"Code Review Best Practices","text":""},{"location":"modules/git/05-collaboration/#as-the-author","title":"As the author","text":"<ul> <li>Keep PRs small. Smaller changes are easier to review and less likely to have bugs. If a feature is large, break it into smaller PRs.</li> <li>Write a clear description. Explain what and why, not just what files changed.</li> <li>Respond to feedback gracefully. Reviewers are trying to help. If you disagree, discuss it.</li> <li>Test before requesting review. Don't waste reviewers' time on broken code.</li> </ul>"},{"location":"modules/git/05-collaboration/#as-a-reviewer","title":"As a reviewer","text":"<ul> <li>Be constructive. Suggest improvements, don't just criticize.</li> <li>Explain your reasoning. \"This could cause a race condition because...\" is more helpful than \"This is wrong.\"</li> <li>Approve when it's good enough. Perfect is the enemy of good. If it works and is maintainable, approve it.</li> <li>Review promptly. Slow reviews block others' work.</li> </ul>"},{"location":"modules/git/05-collaboration/#force-push-safety","title":"Force Push Safety","text":"<p><code>git push --force</code> overwrites the remote branch with your local version, destroying any commits that aren't in your local copy.</p> <pre><code># Dangerous on shared branches!\ngit push --force\n</code></pre>"},{"location":"modules/git/05-collaboration/#when-force-push-is-acceptable","title":"When force push is acceptable","text":"<ul> <li>On your own feature branch that no one else is using</li> <li>After squashing commits before merge</li> <li>After rebasing to update your branch</li> </ul>"},{"location":"modules/git/05-collaboration/#when-force-push-is-dangerous","title":"When force push is dangerous","text":"<ul> <li>On <code>main</code> or any shared branch</li> <li>On any branch someone else might have pulled</li> </ul>"},{"location":"modules/git/05-collaboration/#use-force-with-lease-instead","title":"Use --force-with-lease instead","text":"<pre><code>git push --force-with-lease\n</code></pre> <p>This fails if the remote branch has commits you don't have locally (meaning someone else pushed). It's not foolproof, but it catches the most common mistakes.</p> <p>Never force push to main</p> <p>Force pushing to <code>main</code> can delete others' work and break everyone's local repositories. Many teams protect <code>main</code> to prevent this entirely.</p>"},{"location":"modules/git/05-collaboration/#common-scenarios","title":"Common Scenarios","text":""},{"location":"modules/git/05-collaboration/#my-pr-has-conflicts-with-main","title":"\"My PR has conflicts with main\"","text":"<pre><code>git checkout my-feature\ngit fetch origin\ngit merge origin/main\n# Resolve conflicts in your editor\ngit add .\ngit commit -m \"Merge main into my-feature\"\ngit push\n</code></pre>"},{"location":"modules/git/05-collaboration/#i-need-to-update-my-pr-with-more-changes","title":"\"I need to update my PR with more changes\"","text":"<p>Just commit and push to the same branch:</p> <pre><code>git checkout my-feature\n# Make changes\ngit add .\ngit commit -m \"Add requested error handling\"\ngit push\n</code></pre> <p>The PR updates automatically.</p>"},{"location":"modules/git/05-collaboration/#i-want-to-squash-my-commits-before-merging","title":"\"I want to squash my commits before merging\"","text":"<pre><code>git checkout my-feature\ngit rebase -i HEAD~n  # n = number of commits to squash\n# Change 'pick' to 'squash' for all but the first\n# Write a new commit message\ngit push --force-with-lease\n</code></pre>"},{"location":"modules/git/05-collaboration/#someone-else-pushed-to-my-branch","title":"\"Someone else pushed to my branch\"","text":"<p>Pull their changes before continuing:</p> <pre><code>git checkout my-feature\ngit pull\n</code></pre> <p>If you've already made local commits, this creates a merge commit. That's fine.</p>"},{"location":"modules/git/05-collaboration/#exercises","title":"Exercises","text":"<ol> <li> <p>Practice the PR workflow: Create a branch, make a few commits, push it, and open a PR (even if you're the only reviewer). Merge it using the web interface.</p> </li> <li> <p>Try squash and merge: Open a PR with multiple commits. When merging, use the \"Squash and merge\" option. Check the history on <code>main</code> to see the single combined commit.</p> </li> <li> <p>Squash locally: Create a branch with 3-4 small commits. Use <code>git rebase -i</code> to squash them into one. Push with <code>--force-with-lease</code>.</p> </li> <li> <p>Resolve a conflict: Create two branches from <code>main</code>. On each, edit the same line differently. Merge one to <code>main</code>. On the other branch, merge <code>main</code> in and resolve the conflict. Push and complete the PR.</p> </li> <li> <p>Review a PR: If you're working with others, review someone else's PR. Practice leaving constructive feedback.</p> </li> </ol>"},{"location":"modules/git/06-recovery-and-confidence/","title":"Recovery and Confidence","text":"<p>By the end of this section, you'll know how to undo mistakes at every stage of the Git workflow. More importantly, you'll have the confidence to experiment knowing you can always get back to a good state.</p>"},{"location":"modules/git/06-recovery-and-confidence/#the-safety-net-mindset","title":"The Safety Net Mindset","text":"<p>Git is designed to be recoverable. Almost nothing you do is permanent until you push to a shared remote, and even then there are options. The commands in this section are your safety net.</p> <p>Before we dive in, remember: <code>git status</code> is your friend. When something goes wrong, run it first. Git usually tells you exactly what's happening and suggests how to fix it.</p>"},{"location":"modules/git/06-recovery-and-confidence/#undoing-uncommitted-changes","title":"Undoing Uncommitted Changes","text":"<p>These commands help when you've made changes to files but haven't committed yet.</p>"},{"location":"modules/git/06-recovery-and-confidence/#discard-changes-to-a-file","title":"Discard changes to a file","text":"<p>You edited a file and want to throw away those changes, restoring it to the last committed version:</p> <pre><code>git restore notes.md\n</code></pre> <p>The file reverts to how it looked in your last commit. Your changes are gone (there's no undo for this, so be sure).</p> <p>Destructive command</p> <p><code>git restore</code> permanently discards uncommitted changes. If you're unsure, stash your changes first (covered below) so you can get them back if needed.</p> <p>To discard changes to all files in the current directory:</p> <pre><code>git restore .\n</code></pre>"},{"location":"modules/git/06-recovery-and-confidence/#unstage-a-file","title":"Unstage a file","text":"<p>You ran <code>git add</code> but changed your mind. The file is staged, but you want to remove it from the staging area without losing your changes:</p> <pre><code>git restore --staged notes.md\n</code></pre> <p>This only unstages the file. Your edits are still in the working directory, just no longer queued for the next commit. Run <code>git status</code> and you'll see the file moved from \"Changes to be committed\" back to \"Changes not staged for commit.\"</p> <p>From here you have two options:</p> <ul> <li>Re-stage it later with <code>git add notes.md</code> when you're ready</li> <li>Discard the changes entirely with <code>git restore notes.md</code> (no <code>--staged</code> flag)</li> </ul> <p>The two-step process (unstage, then discard) is intentional. It prevents you from accidentally throwing away work when you just wanted to unstage.</p> <p>To unstage everything:</p> <pre><code>git restore --staged .\n</code></pre>"},{"location":"modules/git/06-recovery-and-confidence/#the-old-way-git-checkout-and-git-reset","title":"The old way: git checkout and git reset","text":"<p>Before <code>git restore</code> existed, people used <code>git checkout -- filename</code> to discard changes and <code>git reset HEAD filename</code> to unstage. You'll see these in older tutorials and Stack Overflow answers. They still work, but <code>git restore</code> is clearer about what it does.</p>"},{"location":"modules/git/06-recovery-and-confidence/#stashing-changes","title":"Stashing Changes","text":"<p>Sometimes you need to switch branches but have uncommitted work you're not ready to commit. Stashing saves your changes temporarily.</p>"},{"location":"modules/git/06-recovery-and-confidence/#save-your-work","title":"Save your work","text":"<pre><code>git stash\n</code></pre> <p>Your working directory is now clean (matching the last commit), and your changes are saved in the stash.</p>"},{"location":"modules/git/06-recovery-and-confidence/#see-whats-stashed","title":"See what's stashed","text":"<pre><code>git stash list\n</code></pre> <pre><code>stash@{0}: WIP on main: a1b2c3d Add backup procedures\n</code></pre>"},{"location":"modules/git/06-recovery-and-confidence/#get-your-changes-back","title":"Get your changes back","text":"<pre><code>git stash pop\n</code></pre> <p>This applies the most recent stash and removes it from the stash list. Your changes are back in your working directory.</p> <p>If you want to apply the stash but keep it in the list (in case you need it again):</p> <pre><code>git stash apply\n</code></pre>"},{"location":"modules/git/06-recovery-and-confidence/#stash-with-a-message","title":"Stash with a message","text":"<p>The default \"WIP on branch\" message isn't very descriptive. Add your own:</p> <pre><code>git stash push -m \"Halfway through refactoring config parsing\"\n</code></pre> <p>This makes it easier to remember what each stash contains if you have several.</p>"},{"location":"modules/git/06-recovery-and-confidence/#amending-recent-commits","title":"Amending Recent Commits","text":"<p>Made a commit and immediately realized you made a mistake? These commands fix the most recent commit.</p>"},{"location":"modules/git/06-recovery-and-confidence/#fix-the-commit-message","title":"Fix the commit message","text":"<p>You just committed with a typo or unclear message:</p> <pre><code>git commit --amend -m \"Add backup procedures section\"\n</code></pre> <p>This replaces the previous commit message. The commit itself (the actual changes) stays the same.</p>"},{"location":"modules/git/06-recovery-and-confidence/#add-forgotten-files","title":"Add forgotten files","text":"<p>You committed but forgot to include a file:</p> <pre><code>git add forgotten-file.md\ngit commit --amend --no-edit\n</code></pre> <p>The <code>--no-edit</code> flag keeps the existing commit message. Your forgotten file is now part of the commit as if you'd included it originally.</p>"},{"location":"modules/git/06-recovery-and-confidence/#add-more-changes-to-the-last-commit","title":"Add more changes to the last commit","text":"<p>Same idea, but for changes to files already in the commit:</p> <pre><code># Make your additional edits\ngit add notes.md\ngit commit --amend --no-edit\n</code></pre>"},{"location":"modules/git/06-recovery-and-confidence/#fix-an-older-commit","title":"Fix an older commit","text":"<p><code>--amend</code> only works on the most recent commit. To fix an older commit, use interactive rebase.</p> <p>Say you want to fix the commit message from three commits ago:</p> <pre><code>git rebase -i HEAD~3\n</code></pre> <p>Git opens your editor with a list of the last three commits:</p> <pre><code>pick a1b2c3d Add backup procedures\npick b2c3d4e Add monitoring section\npick c3d4e5f Add contact info\n</code></pre> <p>Change <code>pick</code> to <code>reword</code> (or just <code>r</code>) on the commit you want to fix:</p> <pre><code>reword a1b2c3d Add backup procedures\npick b2c3d4e Add monitoring section\npick c3d4e5f Add contact info\n</code></pre> <p>Save and close. Git will open another editor for you to write the new commit message. Save that, and the rebase completes.</p> <p>To change the contents of an older commit (not just the message), use <code>edit</code> instead of <code>reword</code>. Git will pause at that commit, letting you make changes and run <code>git commit --amend</code>, then <code>git rebase --continue</code> to finish.</p> <p>Rebase options</p> <p>The interactive rebase editor shows other options like <code>squash</code> (combine commits), <code>drop</code> (delete a commit), and <code>reorder</code> (change commit order). These are powerful but beyond the scope of this intro.</p> <p>Don't amend or rebase pushed commits</p> <p>Both amending and rebasing rewrite history. If you've already pushed these commits to a shared remote, rewriting them creates problems for anyone who pulled them. Only rewrite commits that exist only on your local machine.</p>"},{"location":"modules/git/06-recovery-and-confidence/#resetting-commits","title":"Resetting Commits","text":"<p>When you need to undo one or more commits entirely, <code>git reset</code> is the tool. It has three modes that determine what happens to your changes.</p>"},{"location":"modules/git/06-recovery-and-confidence/#soft-reset-undo-commit-keep-changes-staged","title":"Soft reset: undo commit, keep changes staged","text":"<pre><code>git reset --soft HEAD~1\n</code></pre> <p>This undoes the last commit but keeps all changes staged. Useful when you want to re-commit with a different message or combine with other changes.</p>"},{"location":"modules/git/06-recovery-and-confidence/#mixed-reset-default-undo-commit-keep-changes-unstaged","title":"Mixed reset (default): undo commit, keep changes unstaged","text":"<pre><code>git reset HEAD~1\n</code></pre> <p>This undoes the last commit and unstages the changes, but keeps them in your working directory. You can review what was in the commit and decide what to do.</p>"},{"location":"modules/git/06-recovery-and-confidence/#hard-reset-undo-commit-discard-changes","title":"Hard reset: undo commit, discard changes","text":"<pre><code>git reset --hard HEAD~1\n</code></pre> <p>This undoes the last commit and throws away all changes. Your working directory matches the commit before the one you reset.</p> <p>Hard reset is destructive</p> <p><code>git reset --hard</code> permanently discards commits and changes. Triple-check you're resetting to the right commit. If you reset too far, see \"Recovering lost commits\" below.</p>"},{"location":"modules/git/06-recovery-and-confidence/#reset-multiple-commits","title":"Reset multiple commits","text":"<p><code>HEAD~1</code> means \"one commit before HEAD.\" Adjust the number:</p> <pre><code>git reset --soft HEAD~3    # Undo last 3 commits, keep changes staged\n</code></pre> <p>Or reset to a specific commit by hash:</p> <pre><code>git reset --hard a1b2c3d\n</code></pre>"},{"location":"modules/git/06-recovery-and-confidence/#common-i-messed-up-scenarios","title":"Common \"I Messed Up\" Scenarios","text":"<p>Here are solutions to situations that make people panic.</p>"},{"location":"modules/git/06-recovery-and-confidence/#i-committed-to-the-wrong-branch","title":"\"I committed to the wrong branch\"","text":"<p>You meant to commit to a feature branch but accidentally committed to <code>main</code>.</p> <p>Solution: Move the commit to the right branch.</p> <pre><code># Create a new branch pointing at your current commit\ngit branch feature-branch\n\n# Reset main back one commit (keeping changes if you use --soft)\ngit reset --hard HEAD~1\n\n# Switch to your feature branch\ngit checkout feature-branch\n</code></pre> <p>Your commit is now on <code>feature-branch</code>, and <code>main</code> is back where it was.</p>"},{"location":"modules/git/06-recovery-and-confidence/#i-need-to-undo-a-commit-thats-already-pushed","title":"\"I need to undo a commit that's already pushed\"","text":"<p>You can't rewrite history that others might have pulled. Instead, create a new commit that reverses the changes:</p> <pre><code>git revert a1b2c3d\n</code></pre> <p>This creates a new commit that undoes everything in commit <code>a1b2c3d</code>. The original commit stays in history (for accountability), but its effects are reversed.</p> <p>To revert the most recent commit:</p> <pre><code>git revert HEAD\n</code></pre>"},{"location":"modules/git/06-recovery-and-confidence/#i-accidentally-deleted-a-branch","title":"\"I accidentally deleted a branch\"","text":"<p>If you deleted a branch with <code>-d</code> or <code>-D</code>, the commits still exist. Find the commit hash:</p> <pre><code>git reflog\n</code></pre> <p>The reflog shows recent commits you've visited, even on deleted branches. Find the commit hash and recreate the branch:</p> <pre><code>git branch recovered-branch a1b2c3d\n</code></pre>"},{"location":"modules/git/06-recovery-and-confidence/#i-did-a-hard-reset-and-lost-commits","title":"\"I did a hard reset and lost commits\"","text":"<p>Same solution: use <code>git reflog</code> to find the commit hash, then reset back to it:</p> <pre><code>git reflog\n# Find the commit you want to return to\ngit reset --hard a1b2c3d\n</code></pre> <p>Reflog is your last resort</p> <p>Git keeps reflog entries for about 90 days by default. If you realize you lost something, act soon. The reflog is local only (it doesn't sync with remotes).</p>"},{"location":"modules/git/06-recovery-and-confidence/#im-in-a-merge-conflict-and-want-to-start-over","title":"\"I'm in a merge conflict and want to start over\"","text":"<pre><code>git merge --abort\n</code></pre> <p>This cancels the merge and returns your branch to its pre-merge state. You can try again or take a different approach.</p> <p>Similarly, for a rebase gone wrong:</p> <pre><code>git rebase --abort\n</code></pre>"},{"location":"modules/git/06-recovery-and-confidence/#i-have-uncommitted-changes-and-cant-switch-branches","title":"\"I have uncommitted changes and can't switch branches\"","text":"<p>Git won't let you switch branches if you have uncommitted changes that would conflict. You have options:</p> <ol> <li> <p>Commit your work (even as a work-in-progress):    <code>bash    git add .    git commit -m \"WIP: save progress before switching\"</code></p> </li> <li> <p>Stash your changes:    <code>bash    git stash    git checkout other-branch    # Later, when you come back:    git stash pop</code></p> </li> <li> <p>Discard your changes (if you don't need them):    <code>bash    git restore .</code></p> </li> </ol>"},{"location":"modules/git/06-recovery-and-confidence/#everything-is-broken-and-i-want-to-start-fresh","title":"\"Everything is broken and I want to start fresh\"","text":"<p>Nuclear option: reset your branch to match the remote exactly.</p> <pre><code>git fetch origin\ngit reset --hard origin/main\n</code></pre> <p>This throws away all local commits and changes, making your local <code>main</code> identical to the remote. Only do this if you're sure you don't need anything local.</p>"},{"location":"modules/git/06-recovery-and-confidence/#building-confidence","title":"Building Confidence","text":"<p>The best way to get comfortable with recovery commands is to practice them intentionally in your sandbox repository. Break things on purpose:</p> <ol> <li>Make commits, then undo them with <code>git reset</code></li> <li>Create merge conflicts, then abort with <code>git merge --abort</code></li> <li>Delete branches, then recover them with <code>git reflog</code></li> <li>Stash changes, switch branches, then pop the stash</li> </ol> <p>The more you practice recovery, the less scary mistakes become. Git almost always has a way out.</p>"},{"location":"modules/git/06-recovery-and-confidence/#exercises","title":"Exercises","text":"<p>These exercises use your sandbox repository. If something goes wrong, you can always delete the sandbox and start fresh.</p> <ol> <li> <p>Practice restore: Modify <code>notes.md</code>, then use <code>git restore</code> to discard the changes. Verify the file is back to its committed state.</p> </li> <li> <p>Unstage a file: Stage a change with <code>git add</code>, then unstage it with <code>git restore --staged</code>. Confirm the change is still in your working directory but no longer staged.</p> </li> <li> <p>Amend a commit: Make a commit with a typo in the message. Use <code>git commit --amend</code> to fix the message. Check <code>git log</code> to verify.</p> </li> <li> <p>Use the stash: Make some changes, stash them, verify your working directory is clean, then pop the stash and verify your changes are back.</p> </li> <li> <p>Reset commits: Make two commits, then use <code>git reset --soft HEAD~2</code> to undo them while keeping changes staged. Re-commit everything as a single commit.</p> </li> <li> <p>Explore reflog: Run <code>git reflog</code> and examine the output. Identify commits from branches you've deleted or resets you've done.</p> </li> </ol>"},{"location":"modules/git/07-branching-strategies/","title":"Branching Strategies","text":"<p>By the end of this section, you'll understand three common approaches to organizing branches on a team, their tradeoffs, and how to recognize which one you're working with.</p> <p>TL;DR: Start with GitHub Flow</p> <p>If you're not sure which strategy to use, GitHub Flow is the safe default. Create a branch for each change, open a pull request, merge to <code>main</code> after review. It's simple, works for most teams, and you can always adopt something more complex later if needed.</p>"},{"location":"modules/git/07-branching-strategies/#why-strategies-matter","title":"Why Strategies Matter","text":"<p>When you're working alone, you can branch however you want. On a team, everyone needs to follow the same conventions or chaos ensues. A branching strategy answers questions like:</p> <ul> <li>Where does new feature work happen?</li> <li>How do changes get to production?</li> <li>How do we handle urgent fixes?</li> <li>What branches exist and what are they for?</li> </ul> <p>There's no single \"right\" strategy. The best choice depends on your team size, release cadence, and how you deploy.</p>"},{"location":"modules/git/07-branching-strategies/#git-flow","title":"Git Flow","text":"<p>Git Flow is a structured model designed for projects with scheduled releases (like versioned software with v1.0, v2.0, etc.).</p>"},{"location":"modules/git/07-branching-strategies/#the-branches","title":"The branches","text":"Branch Purpose Lifespan <code>main</code> Production-ready code, tagged with version numbers Permanent <code>develop</code> Integration branch for features, always deployable to staging Permanent <code>feature/*</code> New features, branched from <code>develop</code> Temporary <code>release/*</code> Preparing a release, branched from <code>develop</code> Temporary <code>hotfix/*</code> Emergency fixes for production, branched from <code>main</code> Temporary"},{"location":"modules/git/07-branching-strategies/#how-it-works","title":"How it works","text":"<pre><code>main     \u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n              \u2502                 \u2191             \u2191\n              \u2502           merge \u2502       merge \u2502\n              \u2502                 \u2502             \u2502\nhotfix   \u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n              \u2502                 \u2502     \u2502\ndevelop  \u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n              \u2502     \u2191     \u2191     \u2191           \u2191\n              \u2502     \u2502     \u2502     \u2502           \u2502\nfeature  \u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518           \u2502\n                                            \u2502\nrelease  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <ol> <li> <p>Feature development: Create <code>feature/add-login</code> from <code>develop</code>. Work on it. Merge back to <code>develop</code> when done.</p> </li> <li> <p>Release preparation: When <code>develop</code> has enough features for a release, create <code>release/1.2.0</code> from <code>develop</code>. Only bug fixes go into the release branch. When ready, merge to both <code>main</code> (and tag it) and back to <code>develop</code>.</p> </li> <li> <p>Hotfixes: Critical bug in production? Create <code>hotfix/fix-crash</code> from <code>main</code>, fix it, merge to both <code>main</code> (tag it) and <code>develop</code>.</p> </li> </ol>"},{"location":"modules/git/07-branching-strategies/#when-to-use-git-flow","title":"When to use Git Flow","text":"<p>Git Flow works well when:</p> <ul> <li>You ship versioned releases on a schedule (monthly, quarterly)</li> <li>You need to maintain multiple versions simultaneously</li> <li>You have a QA phase before releases</li> <li>You're building installable software (desktop apps, libraries, firmware)</li> </ul>"},{"location":"modules/git/07-branching-strategies/#when-to-avoid-git-flow","title":"When to avoid Git Flow","text":"<p>Git Flow adds overhead that isn't worth it when:</p> <ul> <li>You deploy continuously (multiple times per day)</li> <li>You only maintain one production version</li> <li>Your team is small and moves fast</li> <li>You're building a web service with rolling deployments</li> </ul> <p>Git Flow's history</p> <p>Git Flow was introduced in 2010 and became very popular. It solved real problems for its time. However, as continuous deployment became common, many teams found it too heavyweight. The creator himself has noted it's not ideal for web applications with continuous delivery.</p>"},{"location":"modules/git/07-branching-strategies/#github-flow","title":"GitHub Flow","text":"<p>GitHub Flow is a simpler model designed for continuous deployment. If you deploy frequently and only maintain one production version, this is probably what you want.</p>"},{"location":"modules/git/07-branching-strategies/#the-branches_1","title":"The branches","text":"Branch Purpose Lifespan <code>main</code> Always deployable, represents production Permanent <code>feature-name</code> Any new work, branched from <code>main</code> Temporary <p>That's it. Two types of branches.</p>"},{"location":"modules/git/07-branching-strategies/#how-it-works_1","title":"How it works","text":"<pre><code>main     \u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n              \u2502     \u2191     \u2502     \u2191     \u2502     \u2191\n              \u2502     \u2502     \u2502     \u2502     \u2502     \u2502\nfeature  \u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2518\n           (add-login)  (fix-bug)  (update-api)\n</code></pre> <ol> <li>Create a branch from <code>main</code> with a descriptive name</li> <li>Make commits on your branch</li> <li>Open a pull request when ready for review</li> <li>Discuss and review the changes</li> <li>Deploy from the branch to verify in production (optional but recommended)</li> <li>Merge to main after approval</li> </ol>"},{"location":"modules/git/07-branching-strategies/#the-key-principles","title":"The key principles","text":"<ul> <li><code>main</code> is always deployable. Never merge broken code.</li> <li>Branch names describe the work. No prefixes required, but use them if your team likes them.</li> <li>Pull requests are mandatory. All changes go through review.</li> <li>Deploy frequently. Ideally, merge and deploy multiple times per day.</li> </ul>"},{"location":"modules/git/07-branching-strategies/#when-to-use-github-flow","title":"When to use GitHub Flow","text":"<p>GitHub Flow works well when:</p> <ul> <li>You deploy continuously (daily or more)</li> <li>You only have one production version</li> <li>You have good automated testing</li> <li>Your team does code review via pull requests</li> <li>You're building web services or SaaS products</li> </ul>"},{"location":"modules/git/07-branching-strategies/#when-to-avoid-github-flow","title":"When to avoid GitHub Flow","text":"<p>GitHub Flow may not fit when:</p> <ul> <li>You need to maintain multiple release versions</li> <li>You have long QA cycles before releases</li> <li>You can't deploy frequently due to external constraints</li> </ul>"},{"location":"modules/git/07-branching-strategies/#trunk-based-development","title":"Trunk-Based Development","text":"<p>Trunk-Based Development (TBD) takes simplicity further: everyone commits to <code>main</code> (the \"trunk\") with very short-lived branches or no branches at all.</p>"},{"location":"modules/git/07-branching-strategies/#the-philosophy","title":"The philosophy","text":"<p>The core idea: integration pain increases exponentially with branch lifetime. A branch that lives for a day is easy to merge. A branch that lives for a month is a nightmare. So keep branches as short as possible, or eliminate them entirely.</p>"},{"location":"modules/git/07-branching-strategies/#how-it-works_2","title":"How it works","text":"<p>With short-lived branches:</p> <pre><code>main     \u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n              \u2502     \u2191     \u2502     \u2191     \u2502     \u2191\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2518\n            (1-2 days)  (few hours)  (1 day)\n</code></pre> <p>Branches live for hours or a day or two at most. Developers integrate to <code>main</code> at least daily.</p> <p>Without branches:</p> <pre><code>main     \u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n              \u2502     \u2502     \u2502     \u2502     \u2502     \u2502\n            (dev1) (dev2) (dev1) (dev1) (dev2) (dev1)\n</code></pre> <p>Developers commit directly to <code>main</code> multiple times per day. This requires excellent testing and often feature flags.</p>"},{"location":"modules/git/07-branching-strategies/#feature-flags","title":"Feature flags","text":"<p>How do you work on a feature that takes a week if you're committing to <code>main</code> daily? Feature flags.</p> <pre><code>if feature_enabled(\"new_checkout_flow\"):\n    show_new_checkout()\nelse:\n    show_old_checkout()\n</code></pre> <p>You commit incomplete code behind a flag. The flag is off in production, so users don't see it. When the feature is complete and tested, you turn on the flag. If something breaks, turn it off instantly without a deploy.</p>"},{"location":"modules/git/07-branching-strategies/#when-to-use-trunk-based-development","title":"When to use Trunk-Based Development","text":"<p>TBD works well when:</p> <ul> <li>You have excellent automated testing</li> <li>You can deploy multiple times per day</li> <li>Your team is experienced with continuous integration</li> <li>You're willing to invest in feature flag infrastructure</li> <li>You want to minimize merge conflicts</li> </ul>"},{"location":"modules/git/07-branching-strategies/#when-to-avoid-trunk-based-development","title":"When to avoid Trunk-Based Development","text":"<p>TBD may not fit when:</p> <ul> <li>Your testing is unreliable or slow</li> <li>You can't deploy frequently</li> <li>Your team is less experienced with Git</li> <li>You need code review before changes hit <code>main</code> (though some TBD teams do post-commit review)</li> </ul>"},{"location":"modules/git/07-branching-strategies/#choosing-a-strategy","title":"Choosing a Strategy","text":"<p>Here's a decision framework:</p>"},{"location":"modules/git/07-branching-strategies/#start-with-these-questions","title":"Start with these questions","text":"<ol> <li>How often do you deploy?</li> <li>Weekly or less \u2192 Git Flow might fit</li> <li>Daily \u2192 GitHub Flow</li> <li> <p>Multiple times daily \u2192 GitHub Flow or Trunk-Based</p> </li> <li> <p>How many versions do you maintain?</p> </li> <li>Multiple concurrent versions \u2192 Git Flow</li> <li> <p>Just one (latest) \u2192 GitHub Flow or Trunk-Based</p> </li> <li> <p>What's your team's Git experience?</p> </li> <li>Mixed or learning \u2192 GitHub Flow (simpler)</li> <li> <p>Experienced \u2192 Any, including Trunk-Based</p> </li> <li> <p>How good is your automated testing?</p> </li> <li>Comprehensive and fast \u2192 Trunk-Based is viable</li> <li>Gaps or slow \u2192 GitHub Flow with PR reviews as a safety net</li> </ol>"},{"location":"modules/git/07-branching-strategies/#summary-comparison","title":"Summary comparison","text":"Factor Git Flow GitHub Flow Trunk-Based Complexity High Low Low Branch lifespan Days to weeks Hours to days Hours Release style Scheduled versions Continuous Continuous Best for Versioned software Web services High-velocity teams Merge conflicts Common Occasional Rare Requires Release planning PR reviews Excellent CI/CD"},{"location":"modules/git/07-branching-strategies/#what-most-teams-should-start-with","title":"What most teams should start with","text":"<p>If you're unsure, start with GitHub Flow. It's simple enough to learn quickly, structured enough to maintain quality through pull requests, and flexible enough to adapt as your needs change.</p> <p>You can always add complexity later. It's much harder to simplify an overcomplicated workflow.</p>"},{"location":"modules/git/07-branching-strategies/#exercises","title":"Exercises","text":"<ol> <li> <p>Identify the strategy: Look at a few open-source projects on GitHub. Examine their branches, pull requests, and tags. Can you tell which strategy they use?</p> </li> <li> <p>Evaluate your projects: Think about a project you work on. Which strategy would fit best based on how often you deploy and how you release?</p> </li> <li> <p>Try GitHub Flow: In your sandbox repository, practice the GitHub Flow cycle: create a branch, make commits, then imagine opening a PR (or actually open one if you push to a remote).</p> </li> <li> <p>Explore feature flags: Research feature flag services (LaunchDarkly, Unleash, or simple environment variables). Consider how you'd use them to enable trunk-based development.</p> </li> </ol>"},{"location":"modules/puppet/00-index/","title":"Puppet 101","text":"<p>TODO: Overview of Puppet fundamentals.</p>"},{"location":"modules/puppet/00-prerequisites/","title":"Prerequisites","text":""},{"location":"modules/puppet/00-prerequisites/#required-tools","title":"Required Tools","text":"Tool Why You Need It TODO TODO"},{"location":"modules/puppet/00-prerequisites/#required-modules","title":"Required Modules","text":"<p>None. This is a foundational module.</p>"},{"location":"modules/puppet-advanced/00-index/","title":"Puppet 201","text":"<p>TODO: Overview of advanced Puppet topics.</p>"},{"location":"modules/puppet-advanced/00-prerequisites/","title":"Prerequisites","text":""},{"location":"modules/puppet-advanced/00-prerequisites/#required-tools","title":"Required Tools","text":"Tool Why You Need It TODO TODO"},{"location":"modules/puppet-advanced/00-prerequisites/#required-modules","title":"Required Modules","text":"Module Why It's Required Puppet Covers Puppet fundamentals Git Puppet code is managed with Git"},{"location":"tools/","title":"Tools","text":"<p>Reference guides for installing and configuring the tools used across our training modules.</p> <p>Each guide covers installation, basic setup, and tips for getting the most out of the tool. You don't need to install everything upfront\u2014check the prerequisites for each module to see what's required.</p>"},{"location":"tools/#available-tools","title":"Available Tools","text":"Tool Platform Description Homebrew macOS Package manager for installing CLI tools Windows Terminal Windows Modern terminal with tabs, profiles, and WSL integration WSL Windows Run Linux on Windows\u2014recommended for development Visual Studio Code All Code editor with Git integration and remote development Git All Version control system Puppet Development Kit (PDK) All Build and test Puppet modules"},{"location":"tools/git/","title":"Git","text":"<p>Git is a version control system that tracks changes to files over time. You save checkpoints (commits), work on isolated changes (branches), and combine work together (merges). It's the foundation for modern infrastructure-as-code, config management, and collaborative workflows.</p>"},{"location":"tools/git/#installation","title":"Installation","text":""},{"location":"tools/git/#macos","title":"macOS","text":"<p>Homebrew (recommended)</p> <pre><code>brew install git\n</code></pre>"},{"location":"tools/git/#linux-ubuntu-wsl","title":"Linux (Ubuntu) / WSL","text":"<pre><code>sudo apt update &amp;&amp; sudo apt install -y git\n</code></pre> <p>Windows users</p> <p>Install Git inside WSL, not on Windows itself. This keeps your tooling consistent with the Linux environments you'll deploy to.</p>"},{"location":"tools/git/#verify-installation","title":"Verify Installation","text":"<pre><code>git --version\n</code></pre> <p>You should see something like <code>git version 2.x.x</code>.</p>"},{"location":"tools/git/#initial-configuration","title":"Initial Configuration","text":"<p>Set these once per machine. They identify you in every commit you make.</p> <pre><code>git config --global user.name \"Your Name\"\ngit config --global user.email \"you@uoregon.edu\"\n</code></pre> <p>Use your real name and work email. When someone runs <code>git log</code> or <code>git blame</code>, your name/email is what they'll see.</p> <p>Recommended settings:</p> <pre><code>git config --global pull.rebase true    # cleaner history when pulling changes\n</code></pre> <p>Verify your config:</p> <pre><code>git config --global --list\n</code></pre>"},{"location":"tools/homebrew/","title":"Homebrew (macOS)","text":"<p>Homebrew is a package manager that makes it easy to install command line tools on macOS.</p> <ul> <li>Consistent installs for CLI tools across machines.</li> <li>Easy updates: <code>brew update &amp;&amp; brew upgrade</code>.</li> <li>Dependency management: <code>brew info &lt;package&gt;</code> shows versions and requirements.</li> </ul>"},{"location":"tools/homebrew/#prerequisites","title":"Prerequisites","text":"<p>Ensure Command Line Tools are installed:</p> <pre><code>xcode-select --install\n</code></pre>"},{"location":"tools/homebrew/#installation","title":"Installation","text":"<ul> <li>Run the official installer:</li> </ul> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> <ul> <li>Add Homebrew to your shell path (follow the installer's final hints)</li> </ul> <pre><code>echo 'eval \"$(/opt/homebrew/bin/brew shellenv)\"' &gt;&gt; ~/.zprofile\neval \"$(/opt/homebrew/bin/brew shellenv)\"\n</code></pre> <ul> <li>Verify:</li> </ul> <pre><code>brew --version\nbrew doctor\n</code></pre>"},{"location":"tools/pdk/","title":"Puppet Development Kit (PDK)","text":"<p>PDK is Puppet's official toolkit for developing and testing Puppet modules. It provides a consistent environment for creating modules, writing unit tests, validating syntax, and packaging modules for publication. PDK also includes a language server that integrates with editors like VS Code, giving you autocompletion, real-time validation, and inline documentation as you write Puppet code. If you're writing Puppet code, PDK standardizes your workflow and catches errors before they hit production.</p>"},{"location":"tools/pdk/#puppet-forge-account","title":"Puppet Forge Account","text":"<p>You need a Puppet Forge account to download PDK. The download requires accepting Puppet's EULA, which is tied to your Forge account. You may also use this account later to publish modules and generate API keys.</p> <p>Click here for the official instructions, or proceed below for the abridged version.</p>"},{"location":"tools/pdk/#creating-an-account","title":"Creating an Account","text":"<ol> <li>Go to forge.puppet.com</li> <li>Click Sign Up in the top right</li> <li>Create an account using your work email</li> <li>Verify your email address</li> </ol>"},{"location":"tools/pdk/#forge-api-key","title":"Forge API Key","text":"<p>An API key lets you authenticate with the Forge from the command line which is required for downloading the PDK and publishing modules.</p> <ol> <li>Log in to forge.puppet.com</li> <li>Click your username in the top right \u2192 View Profile</li> <li>Select API keys from the sidebar</li> <li>Click Create a new key</li> <li>Give the key a descriptive name (e.g., \"workstation-pdk\")</li> <li>Select a validity. I recommend 365 days if this is your primary key.</li> <li>Copy the key immediately, you won't be able to see it again!</li> </ol> <p>Store the key securely. You'll use it when downloading the PDK or publishing modules.</p>"},{"location":"tools/pdk/#installation","title":"Installation","text":"<p>Browse to the PDK downloads page: https://forge.puppet.com/resources/pdk</p> <p>For each platform, you'll be prompted for authentication to the site.</p> <p>The Username will be <code>forge-key</code> and the password is the API key you previously generated.</p>"},{"location":"tools/pdk/#verify-installation","title":"Verify Installation","text":"<p>Using your terminal of choice, run the following command:</p> <pre><code>pdk --version\n</code></pre> <p>You should see output like <code>3.6.x</code>.</p>"},{"location":"tools/pdk/#editor-integration","title":"Editor Integration","text":"<p>PDK includes a language server that provides intelligent editing features when working with Puppet code. Editors like VS Code can connect to this language server to offer:</p> <ul> <li>Autocompletion: suggests resource types, parameters, and variables as you type</li> <li>Hover documentation: displays inline help for resources, functions, and parameters</li> <li>Real-time validation: highlights syntax errors and style issues without leaving your editor</li> <li>Go to definition: jump to class and defined type declarations across your module</li> <li>Code snippets: insert boilerplate for common patterns like resource declarations</li> </ul> <p>This feedback loop catches mistakes early, before you run <code>pdk validate</code> or push code. Instead of writing Puppet manifests blind and discovering problems later, you get immediate guidance on correct syntax, available parameters, and type mismatches.</p>"},{"location":"tools/pdk/#vs-code-setup","title":"VS Code Setup","text":"<p>Install the Puppet extension from the VS Code marketplace. The extension automatically detects PDK and uses it for validation and language features.</p> <p>After installation:</p> <ol> <li>Open a PDK-generated module folder in VS Code</li> <li>Look for \"Puppet\" in the status bar (bottom right) to confirm the language server is running</li> <li>Open any <code>.pp</code> file to see autocompletion and validation in action</li> </ol> <p>Tip</p> <p>The extension works best when you open the module root folder (the one containing <code>metadata.json</code>) rather than individual files or parent directories.</p>"},{"location":"tools/vscode/","title":"Visual Studio Code","text":"<p>Visual Studio Code is a lightweight editor with strong Git support and useful extensions.</p>"},{"location":"tools/vscode/#windows","title":"Windows","text":"<ul> <li>Install via Winget (recommended):</li> </ul> <pre><code>winget install --id Microsoft.VisualStudioCode -e\n</code></pre> <ul> <li>Verify:</li> </ul> <pre><code>code --version\n</code></pre> <ul> <li>If <code>code</code> is not in PATH, launch VS Code, press <code>Ctrl+Shift+P</code>, run \"Shell Command: Install 'code' command in PATH\", then rerun <code>code --version</code>.</li> </ul>"},{"location":"tools/vscode/#macos","title":"macOS","text":"<ul> <li>Install via Homebrew:</li> </ul> <pre><code>brew install --cask visual-studio-code\n</code></pre> <ul> <li>Verify:</li> </ul> <pre><code>code --version\n</code></pre> <ul> <li>If <code>code</code> is not found, open VS Code, press <code>Cmd+Shift+P</code>, and run \"Shell Command: Install 'code' command in PATH\".</li> </ul>"},{"location":"tools/vscode/#linux-debianubuntu","title":"Linux (Debian/Ubuntu)","text":"<ul> <li>Install Microsoft\u2019s repo and package:</li> </ul> <pre><code>sudo apt update\nsudo apt install -y wget gpg\nwget -qO- https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor &gt; packages.microsoft.gpg\nsudo install -D -o root -g root -m 644 packages.microsoft.gpg /etc/apt/keyrings/packages.microsoft.gpg\necho \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/packages.microsoft.gpg] https://packages.microsoft.com/repos/code stable main\" | sudo tee /etc/apt/sources.list.d/vscode.list\nsudo apt update\nsudo apt install -y code\ncode --version\n</code></pre> <ul> <li>Clean up the downloaded key file if desired:</li> </ul> <pre><code>rm -f packages.microsoft.gpg\n</code></pre>"},{"location":"tools/vscode/#settings-sync-with-github","title":"Settings Sync with GitHub","text":"<p>I recommend signing into VS Code using your GitHub account as it will allow you to sync your editor settings and profiles so you can have a consistent experience across devices.</p>"},{"location":"tools/vscode/#recommended-settings-and-extensions","title":"Recommended Settings and Extensions","text":""},{"location":"tools/vscode/#settings","title":"Settings","text":"<p>These are a couple of settings I always encourage new users to configure.</p> <p>To access your settings, press <code>Ctrl+Shift+P</code> on Windows/Linux or <code>Cmd+Shift+P</code> on macOS, type \"Settings\", and select \"Preferences: Open Settings (UI)\".</p> <ul> <li>Enable format on save</li> <li>Disable \"compact folders\"</li> <li>Disable \"workbench editor preview\"</li> </ul>"},{"location":"tools/vscode/#extensions","title":"Extensions","text":"<p>VS Code has a huge amount of useful extensions. I've listed some of my recommended extensions below:</p> <ul> <li>Bash IDE (macOS/Linux, bash language server)</li> <li>Powershell (Windows, powershell language server)</li> <li>Error Lens (nice error messages)</li> <li>markdownlint (formatting for Markdown)</li> <li>Prettier - Code formatter (formatter for many filetypes)</li> <li>Puppet (for Puppet modules)</li> <li>Python (Python support)</li> <li>Ruby LSP (Ruby support for working with Puppet)</li> <li>YAML (the one from Red Hat, use for YAML support)</li> </ul>"},{"location":"tools/windows-terminal/","title":"Windows Terminal","text":"<p>Windows Terminal is a modern, tabbed terminal for Windows that handles PowerShell, Command Prompt, and WSL in one app. It supports Unicode, GPU-accelerated text rendering, and custom themes\u2014everything the legacy console lacks.</p>"},{"location":"tools/windows-terminal/#installation","title":"Installation","text":"<p>Option 1: Microsoft Store (recommended\u2014auto-updates)</p> <p>Open the Microsoft Store, search for \"Windows Terminal,\" and install.</p> <p>Option 2: WinGet</p> <pre><code>winget install --id Microsoft.WindowsTerminal -e\n</code></pre>"},{"location":"tools/windows-terminal/#verify-installation","title":"Verify Installation","text":"<p>Launch Windows Terminal from the Start menu. You should see a tabbed interface with PowerShell as the default.</p> <p>Check the version:</p> <pre><code>wt -v\n</code></pre>"},{"location":"tools/windows-terminal/#set-wsl-as-default-profile","title":"Set WSL as Default Profile","text":"<p>If you're using WSL for development, make it your default so new tabs open directly into Linux.</p> <ol> <li>Open Windows Terminal</li> <li>Press <code>Ctrl+,</code> to open Settings (or click the dropdown arrow \u2192 Settings)</li> <li>Under Startup, find Default profile</li> <li>Select Ubuntu (or your WSL distro) from the dropdown</li> <li>Click Save</li> </ol> <p>New tabs and windows now open in WSL by default. You can still open PowerShell or CMD tabs from the dropdown menu.</p>"},{"location":"tools/windows-terminal/#tips","title":"Tips","text":"<ul> <li>Split panes: <code>Alt+Shift+D</code> splits the current tab. Useful for running a command while watching logs.</li> <li>Zoom: <code>Ctrl+=</code> and <code>Ctrl+-</code> adjust font size on the fly.</li> </ul>"},{"location":"tools/wsl/","title":"Windows Subsystem for Linux (WSL)","text":"<p>WSL lets you run a full Linux environment directly on Windows\u2014no virtual machine, no dual-boot. You get a real Linux shell, real Linux tools, and real Linux package managers, all integrated with your Windows filesystem.</p>"},{"location":"tools/wsl/#why-use-wsl-for-development","title":"Why Use WSL for Development?","text":"<p>Most servers, containers, and CI/CD pipelines run Linux. When you develop on Windows but deploy to Linux, you're constantly fighting small differences: path separators, line endings, case sensitivity, shell syntax, missing tools.</p> <p>WSL eliminates this friction:</p> <ul> <li>Same tools as production. Use the same shell, package manager, and utilities you'll find on your servers. No more \"works on my machine\" because your machine is Linux.</li> <li>Native performance. WSL 2 runs a real Linux kernel. File operations, compilation, and container workloads run at near-native speed.</li> <li>Seamless integration. Access Windows files from Linux (<code>/mnt/c/</code>), run Linux commands from PowerShell, and use VS Code's Remote-WSL extension to edit Linux files with full IDE support.</li> <li>Better tooling support. Many development tools (Docker, Kubernetes, Terraform, Ansible, Puppet) are Linux-first. Documentation, tutorials, and Stack Overflow answers assume Linux. Stop translating\u2014just use Linux.</li> </ul> <p>If you're doing infrastructure work, writing scripts, or working with containers, WSL is the path of least resistance on Windows.</p>"},{"location":"tools/wsl/#installation","title":"Installation","text":""},{"location":"tools/wsl/#requirements","title":"Requirements","text":"<ul> <li>Windows 10 version 2004+ (Build 19041+) or Windows 11</li> <li>Virtualization enabled in BIOS (usually on by default)</li> </ul>"},{"location":"tools/wsl/#install-wsl","title":"Install WSL","text":"<p>Open PowerShell as Administrator and run:</p> <pre><code>wsl --install\n</code></pre> <p>This installs WSL 2 with Ubuntu as the default distribution. Restart when prompted.</p> <p>After restart, Ubuntu will launch automatically to complete setup. Create a username and password\u2014this is your Linux user, separate from your Windows account.</p>"},{"location":"tools/wsl/#verify-installation","title":"Verify Installation","text":"<p>Open a new PowerShell window:</p> <pre><code>wsl --version\n</code></pre> <p>You should see WSL version 2.x.x and a kernel version.</p> <p>Launch your Linux environment:</p> <pre><code>wsl\n</code></pre> <p>You're now in a bash shell. Run <code>uname -a</code> to confirm you're in Linux.</p>"},{"location":"tools/wsl/#basic-configuration","title":"Basic Configuration","text":""},{"location":"tools/wsl/#update-packages","title":"Update Packages","text":"<p>First thing after install\u2014update your package list:</p> <pre><code>sudo apt update &amp;&amp; sudo apt upgrade -y\n</code></pre>"},{"location":"tools/wsl/#install-common-tools","title":"Install Common Tools","text":"<pre><code>sudo apt install -y git curl wget unzip\n</code></pre>"},{"location":"tools/wsl/#access-windows-files","title":"Access Windows Files","text":"<p>Your Windows drives are mounted under <code>/mnt/</code>:</p> <pre><code>cd /mnt/c/Users/YourName/Documents\nls\n</code></pre>"},{"location":"tools/wsl/#access-linux-files-from-windows","title":"Access Linux Files from Windows","text":"<p>Your Linux home directory is accessible from Windows Explorer:</p> <pre><code>\\\\wsl$\\Ubuntu\\home\\yourusername\n</code></pre> <p>Or open Explorer from the Linux terminal:</p> <pre><code>explorer.exe .\n</code></pre>"},{"location":"tools/wsl/#using-wsl-with-vs-code","title":"Using WSL with VS Code","text":"<p>Install the Remote - WSL extension in VS Code.</p> <p>Then from your Linux terminal, open any folder in VS Code:</p> <pre><code>code .\n</code></pre> <p>VS Code connects to WSL and runs extensions inside Linux. You get full IntelliSense, debugging, and terminal access\u2014all running in your Linux environment.</p>"},{"location":"tools/wsl/#tips","title":"Tips","text":"<ul> <li>Keep projects in Linux filesystem. Store code in <code>~/projects</code>, not <code>/mnt/c/</code>. File operations are significantly faster on the Linux filesystem.</li> <li>Use Windows Terminal. It handles WSL, PowerShell, and CMD in tabs with proper Unicode support. See Windows Terminal.</li> <li>One distro is usually enough. Ubuntu is the default and has the best support. You can install multiple distros, but you probably don't need to.</li> </ul>"}]}