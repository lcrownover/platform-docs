{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"ai-disclaimer/","title":"AI Disclaimer","text":"<p>This documentation site was built with assistance from AI tools.</p>"},{"location":"ai-disclaimer/#how-ai-was-used","title":"How AI Was Used","text":"<ul> <li>Content drafting: AI helped write initial drafts of documentation, which were then reviewed and edited by humans.</li> <li>Code examples: AI generated many of the code snippets and terminal examples, verified for accuracy before publishing.</li> <li>Site structure: AI assisted with organizing content and suggesting improvements to navigation and flow.</li> </ul>"},{"location":"ai-disclaimer/#what-this-means-for-you","title":"What This Means for You","text":"<p>The content has been reviewed for accuracy, but AI-generated material can contain errors. If you find something that doesn't work or seems wrong, please let us know.</p>"},{"location":"ai-disclaimer/#why-were-transparent-about-this","title":"Why We're Transparent About This","text":"<p>AI tools are becoming common in technical writing. We believe you should know how content is produced so you can evaluate it appropriately. Using AI doesn't mean lower quality\u2014it means we can produce more documentation faster while maintaining human oversight.</p>"},{"location":"ai-disclaimer/#tools-used","title":"Tools Used","text":"<ul> <li>Claude by Anthropic</li> </ul>"},{"location":"git-101/","title":"Git 101","text":"<p>You've probably been there: a config file that worked yesterday is broken today, and nobody knows what changed. Or you're afraid to touch a script because there's no way to undo it. Or you're emailing files back and forth with <code>-v2-final-FINAL.txt</code> in the name.</p> <p>Git solves these problems. It tracks every change you make, who made it, and why\u2014so you can experiment freely, collaborate without stepping on each other, and always get back to a known-good state.</p>"},{"location":"git-101/#why-you-should-care","title":"Why You Should Care","text":"<p>If you manage configs, scripts, documentation, or infrastructure-as-code, Git gives you:</p> <ul> <li>A real undo button. Made a bad change? Roll back to any previous version in seconds.</li> <li>Fearless experimentation. Try risky changes on a branch. If it works, merge it. If not, delete it. Your main copy stays safe.</li> <li>Accountability without blame. When something breaks at 2 AM, <code>git log</code> and <code>git blame</code> tell you exactly what changed and when\u2014so you can fix it instead of guessing.</li> <li>Collaboration that scales. Multiple people can work on the same files without overwriting each other's work.</li> </ul>"},{"location":"git-101/#lessons","title":"Lessons","text":"<p>Work through these in order:</p> <ol> <li>Local Foundations \u2014 Set up Git, create a repo, make your first commits</li> <li>Understanding History \u2014 Read logs, compare changes, ignore files you don't want tracked</li> <li>Branching and Merging \u2014 Work on isolated changes and combine them safely</li> <li>Working with Remotes \u2014 Sync with shared repositories (push, pull, clone)</li> <li>Recovery and Confidence \u2014 Fix mistakes and get unstuck</li> </ol>"},{"location":"git-101/#tips-for-success","title":"Tips for Success","text":"<ul> <li>Use a scratch repo. Create a throwaway folder to experiment in. Break things on purpose. Delete it and start over when you get stuck\u2014that's the fastest way to learn.</li> <li>Run <code>git status</code> constantly. Before and after every operation. It tells you exactly what Git sees, and it's the quickest way to stay oriented.</li> <li>Don't memorize\u2014understand. Git has a lot of commands, but they all revolve around a few core concepts. Once those click, the commands make sense.</li> </ul>"},{"location":"git-101/lesson-01-local-foundations/","title":"Local Foundations","text":"<p>By the end of this section, you'll have Git configured, a repository created, and your first commits under your belt.</p>"},{"location":"git-101/lesson-01-local-foundations/#configure-your-identity","title":"Configure Your Identity","text":"<p>Before you make any commits, Git needs to know who you are. This information appears in every commit you make\u2014it's how your team knows who changed what.</p> <p>If you haven't already, complete the Initial Configuration steps in the Git tool guide. This sets your name and email globally so you don't have to configure it for each repository.</p> <p>Global vs Local Config</p> <p>The <code>--global</code> flag sets these values for all repositories on your machine. You can override them per-repository by running the same commands without <code>--global</code> from inside a repo.</p>"},{"location":"git-101/lesson-01-local-foundations/#create-your-first-repository","title":"Create Your First Repository","text":"<p>Let's create a scratch repository you can experiment with freely.</p> <pre><code>mkdir -p ~/scratch/git-sandbox\ncd ~/scratch/git-sandbox\n</code></pre> <p>Now initialize Git:</p> <pre><code>git init\n</code></pre> <p>You'll see: <code>Initialized empty Git repository in .../git-sandbox/.git/</code></p> <p>That <code>.git</code> folder is where Git stores everything\u2014all your history, branches, and metadata. You'll never need to touch it directly, but knowing it exists helps demystify what Git is doing.</p> <p>Run your first status check:</p> <pre><code>git status\n</code></pre> <p>You'll see something like:</p> <pre><code>On branch main\nNo commits yet\nnothing to commit (create/copy some files and use \"git add\" to track)\n</code></pre> <p>This tells you three things:</p> <ol> <li>You're on a branch called <code>main</code> (we'll cover branches later)</li> <li>There are no commits yet</li> <li>There's nothing to commit because the folder is empty</li> </ol>"},{"location":"git-101/lesson-01-local-foundations/#the-stage-and-commit-workflow","title":"The Stage and Commit Workflow","text":"<p>Here's where Git differs from simple backup systems. Git doesn't automatically track every file or save every change. You explicitly tell it what to record. This happens in two steps:</p> <ol> <li>Stage \u2014 Select which changes you want to include in your next commit</li> <li>Commit \u2014 Save those staged changes as a permanent snapshot</li> </ol> <p>Think of it like packing a box before shipping it. You don't throw everything in at once\u2014you choose what goes in the box (staging), then seal and label it (commit).</p>"},{"location":"git-101/lesson-01-local-foundations/#create-a-file-and-check-status","title":"Create a file and check status","text":"<pre><code>echo \"# Server Notes\" &gt; notes.md\ngit status\n</code></pre> <p>Git now shows <code>notes.md</code> as an \"untracked file.\" Git sees it exists but isn't tracking changes to it yet.</p>"},{"location":"git-101/lesson-01-local-foundations/#stage-the-file","title":"Stage the file","text":"<pre><code>git add notes.md\ngit status\n</code></pre> <p>Now <code>notes.md</code> appears under \"Changes to be committed.\" It's staged\u2014ready to be included in your next commit.</p> <p>Stage multiple files at once</p> <p><code>git add .</code> stages all changes in the current directory. Useful, but be careful\u2014make sure you're not staging files you don't want (like secrets or build artifacts). Always run <code>git status</code> first.</p>"},{"location":"git-101/lesson-01-local-foundations/#commit-the-staged-changes","title":"Commit the staged changes","text":"<pre><code>git commit -m \"Add server notes file\"\n</code></pre> <p>Done. You've created your first commit. Git responds with a summary:</p> <pre><code>[main (root-commit) a1b2c3d] Add server notes file\n 1 file changed, 1 insertion(+)\n create mode 100644 notes.md\n</code></pre> <p>The string <code>a1b2c3d</code> is an abbreviated commit hash\u2014a unique identifier for this exact snapshot. Every commit gets one.</p>"},{"location":"git-101/lesson-01-local-foundations/#the-full-cycle","title":"The full cycle","text":"<p>Let's do it again to reinforce the pattern. Edit the file:</p> <pre><code>echo \"Reboot procedure: sudo reboot\" &gt;&gt; notes.md\n</code></pre> <p>Check what changed:</p> <pre><code>git status\n</code></pre> <p>Git shows <code>notes.md</code> as \"modified.\" It's already tracked, so Git notices the change, but that change isn't staged yet.</p> <p>See exactly what changed:</p> <pre><code>git diff\n</code></pre> <p>This shows the lines added (prefixed with <code>+</code>) and removed (prefixed with <code>-</code>). Get comfortable with <code>git diff</code>\u2014it's your preview before committing.</p> <p>Stage and commit:</p> <pre><code>git add notes.md\ngit commit -m \"Add reboot procedure to server notes\"\n</code></pre>"},{"location":"git-101/lesson-01-local-foundations/#why-two-steps","title":"Why two steps?","text":"<p>The staging area lets you craft clean, logical commits even when your working directory is messy. You might have three files changed, but only two are related to the same task. Stage those two, commit them, then stage and commit the third separately.</p> <p>Clean commits make history easier to read and problems easier to diagnose. When something breaks, you want to find \"Add SSL config\" in your history\u2014not \"Various changes and fixes.\"</p>"},{"location":"git-101/lesson-01-local-foundations/#writing-good-commit-messages","title":"Writing Good Commit Messages","text":"<p>Commit messages are for your future self and your teammates. Write them like you'll be the one debugging this at 2 AM six months from now.</p>"},{"location":"git-101/lesson-01-local-foundations/#use-imperative-mood","title":"Use imperative mood","text":"<p>Write messages as commands: \"Add config file\" not \"Added config file\" or \"Adding config file.\"</p> <p>This matches Git's own conventions (e.g., \"Merge branch 'feature'\") and reads naturally when you look at history: \"If I apply this commit, it will Add config file.\"</p> <p>Good:</p> <ul> <li><code>Add SSL certificate rotation script</code></li> <li><code>Fix incorrect timeout in backup job</code></li> <li><code>Remove deprecated API endpoint</code></li> </ul> <p>Bad:</p> <ul> <li><code>Added some stuff</code></li> <li><code>WIP</code></li> <li><code>asdfasdf</code></li> <li><code>Fixed it</code></li> </ul>"},{"location":"git-101/lesson-01-local-foundations/#be-specific","title":"Be specific","text":"<p>Your message should explain what changed and, briefly, why. Someone reading the log should understand the intent without reading the code.</p> Instead of... Write... <code>Update config</code> <code>Increase nginx worker connections to 4096</code> <code>Fix bug</code> <code>Fix race condition in session cleanup</code> <code>Changes</code> <code>Add retry logic to LDAP connection</code>"},{"location":"git-101/lesson-01-local-foundations/#keep-the-first-line-short","title":"Keep the first line short","text":"<p>The first line should be under 50 characters\u2014this is what appears in logs, GitHub, and most Git tools. If you need more detail, add a blank line and then a longer description:</p> <pre><code>git commit -m \"Add retry logic to LDAP connection\n\nPrevious implementation failed silently on network timeouts.\nNow retries 3 times with exponential backoff before failing.\"\n</code></pre>"},{"location":"git-101/lesson-01-local-foundations/#exercises","title":"Exercises","text":"<ol> <li> <p>Practice the cycle: Create two more files in your sandbox, stage them separately, and commit each with a descriptive message. Run <code>git status</code> before and after each command to see how the state changes.</p> </li> <li> <p>Selective staging: Modify two files, but only stage and commit one. Verify the other file still shows as modified after the commit.</p> </li> <li> <p>View your history: Run <code>git log</code> to see your commits. Try <code>git log --oneline</code> for a compact view. We'll dig deeper into history in the next section.</p> </li> </ol>"},{"location":"git-101/lesson-02-understanding-history/","title":"Understanding History","text":"<p>Goal: Read your project's history, compare changes, and keep your repository clean.</p>"},{"location":"git-101/lesson-02-understanding-history/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Navigate commit history with <code>git log</code></li> <li>Compare changes with <code>git diff</code></li> <li>Use <code>.gitignore</code> for secrets, build artifacts, and OS clutter</li> <li>Find who changed what with <code>git blame</code></li> </ul>"},{"location":"git-101/lesson-02-understanding-history/#reading-the-commit-log","title":"Reading the Commit Log","text":"<p>TODO</p>"},{"location":"git-101/lesson-02-understanding-history/#comparing-changes-with-diff","title":"Comparing Changes with Diff","text":"<p>TODO</p>"},{"location":"git-101/lesson-02-understanding-history/#ignoring-files-with-gitignore","title":"Ignoring Files with .gitignore","text":"<p>TODO</p>"},{"location":"git-101/lesson-02-understanding-history/#finding-who-changed-what","title":"Finding Who Changed What","text":"<p>TODO</p>"},{"location":"git-101/lesson-02-understanding-history/#exercises","title":"Exercises","text":"<p>TODO</p>"},{"location":"git-101/lesson-03-branching-and-merging/","title":"Branching and Merging","text":"<p>Goal: Work on isolated changes and combine them back together.</p>"},{"location":"git-101/lesson-03-branching-and-merging/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Create and switch between branches</li> <li>Merge branches and handle simple conflicts</li> <li>Decide when to branch vs. commit directly</li> </ul>"},{"location":"git-101/lesson-03-branching-and-merging/#why-branches-exist","title":"Why Branches Exist","text":"<p>TODO</p>"},{"location":"git-101/lesson-03-branching-and-merging/#creating-and-switching-branches","title":"Creating and Switching Branches","text":"<p>TODO</p>"},{"location":"git-101/lesson-03-branching-and-merging/#merging-branches","title":"Merging Branches","text":"<p>TODO</p>"},{"location":"git-101/lesson-03-branching-and-merging/#handling-merge-conflicts","title":"Handling Merge Conflicts","text":"<p>TODO</p>"},{"location":"git-101/lesson-03-branching-and-merging/#when-to-branch","title":"When to Branch","text":"<p>TODO</p>"},{"location":"git-101/lesson-03-branching-and-merging/#exercises","title":"Exercises","text":"<p>TODO</p>"},{"location":"git-101/lesson-04-working-with-remotes/","title":"Working with Remotes","text":"<p>Goal: Sync your work with a shared repository.</p>"},{"location":"git-101/lesson-04-working-with-remotes/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Clone existing repositories</li> <li>Push your changes and pull others' changes</li> <li>Safe daily habits for working with remotes</li> </ul>"},{"location":"git-101/lesson-04-working-with-remotes/#what-is-a-remote","title":"What Is a Remote?","text":"<p>TODO</p>"},{"location":"git-101/lesson-04-working-with-remotes/#cloning-a-repository","title":"Cloning a Repository","text":"<p>TODO</p>"},{"location":"git-101/lesson-04-working-with-remotes/#push-pull-and-fetch","title":"Push, Pull, and Fetch","text":"<p>TODO</p>"},{"location":"git-101/lesson-04-working-with-remotes/#safe-habits-for-shared-repositories","title":"Safe Habits for Shared Repositories","text":"<p>TODO</p>"},{"location":"git-101/lesson-04-working-with-remotes/#exercises","title":"Exercises","text":"<p>TODO</p>"},{"location":"git-101/lesson-05-recovery-and-confidence/","title":"Recovery and Confidence","text":"<p>Goal: Fix mistakes and get unstuck without panic.</p>"},{"location":"git-101/lesson-05-recovery-and-confidence/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Undo uncommitted changes</li> <li>Amend recent commits</li> <li>Safe ways to recover when things go wrong</li> </ul>"},{"location":"git-101/lesson-05-recovery-and-confidence/#undoing-uncommitted-changes","title":"Undoing Uncommitted Changes","text":"<p>TODO</p>"},{"location":"git-101/lesson-05-recovery-and-confidence/#amending-recent-commits","title":"Amending Recent Commits","text":"<p>TODO</p>"},{"location":"git-101/lesson-05-recovery-and-confidence/#common-i-messed-up-scenarios","title":"Common \"I Messed Up\" Scenarios","text":"<p>TODO</p>"},{"location":"git-101/lesson-05-recovery-and-confidence/#exercises","title":"Exercises","text":"<p>TODO</p>"},{"location":"git-101/prerequisites/","title":"Prerequisites","text":""},{"location":"git-101/prerequisites/#required-tools","title":"Required Tools","text":"Tool Why You Need It Terminal You'll run all Git commands here. macOS/Linux: use the built-in terminal. Windows: use WSL. Git The version control system this module teaches"},{"location":"git-101/prerequisites/#recommended-tools","title":"Recommended Tools","text":"Tool Why It Helps Visual Studio Code Makes merge conflicts much easier to resolve with its built-in diff viewer"},{"location":"git-101/prerequisites/#required-modules","title":"Required Modules","text":"<p>None. This is a foundational module.</p>"},{"location":"tools/","title":"Tools","text":"<p>Reference guides for installing and configuring the tools used across our training modules.</p> <p>Each guide covers installation, basic setup, and tips for getting the most out of the tool. You don't need to install everything upfront\u2014check the prerequisites for each module to see what's required.</p>"},{"location":"tools/#available-tools","title":"Available Tools","text":"Tool Platform Description Homebrew macOS Package manager for installing CLI tools Windows Terminal Windows Modern terminal with tabs, profiles, and WSL integration WSL Windows Run Linux on Windows\u2014recommended for development Visual Studio Code All Code editor with Git integration and remote development Git All Version control system"},{"location":"tools/git/","title":"Git","text":"<p>Git is a version control system that tracks changes to files over time. You save checkpoints (commits), work on isolated changes (branches), and combine work together (merges). It's the foundation for modern infrastructure-as-code, config management, and collaborative workflows.</p>"},{"location":"tools/git/#installation","title":"Installation","text":""},{"location":"tools/git/#macos","title":"macOS","text":"<p>Option 1: Xcode Command Line Tools (quick, but may be outdated)</p> <pre><code>xcode-select --install\n</code></pre> <p>Option 2: Homebrew (recommended\u2014stays current)</p> <pre><code>brew install git\n</code></pre>"},{"location":"tools/git/#linux-wsl","title":"Linux / WSL","text":"<pre><code>sudo apt update &amp;&amp; sudo apt install -y git\n</code></pre> <p>Windows users</p> <p>Install Git inside WSL, not on Windows itself. This keeps your tooling consistent with the Linux environments you'll deploy to.</p>"},{"location":"tools/git/#verify-installation","title":"Verify Installation","text":"<pre><code>git --version\n</code></pre> <p>You should see something like <code>git version 2.x.x</code>.</p>"},{"location":"tools/git/#initial-configuration","title":"Initial Configuration","text":"<p>Set these once per machine. They identify you in every commit you make.</p> <pre><code>git config --global user.name \"Your Name\"\ngit config --global user.email \"you@uoregon.edu\"\n</code></pre> <p>Use your real name and work email\u2014this is attribution, not authentication. When someone runs <code>git log</code> or <code>git blame</code>, your name is what they'll see.</p> <p>Recommended settings:</p> <pre><code>git config --global init.defaultBranch main    # new repos start with 'main' instead of 'master'\ngit config --global pull.rebase true           # cleaner history when pulling changes\n</code></pre> <p>Verify your config:</p> <pre><code>git config --global --list\n</code></pre>"},{"location":"tools/homebrew/","title":"Homebrew (macOS)","text":"<p>Homebrew is a package manager that makes it easy to install command line tools on macOS.</p> <ul> <li>Consistent installs for CLI tools across machines.</li> <li>Easy updates: <code>brew update &amp;&amp; brew upgrade</code>.</li> <li>Dependency management: <code>brew info &lt;package&gt;</code> shows versions and requirements.</li> </ul>"},{"location":"tools/homebrew/#prerequisites","title":"Prerequisites","text":"<p>Ensure Command Line Tools are installed:</p> <pre><code>xcode-select --install\n</code></pre>"},{"location":"tools/homebrew/#installation","title":"Installation","text":"<ul> <li>Run the official installer:</li> </ul> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> <ul> <li>Add Homebrew to your shell path (follow the installer's final hints)</li> </ul> <pre><code>echo 'eval \"$(/opt/homebrew/bin/brew shellenv)\"' &gt;&gt; ~/.zprofile\neval \"$(/opt/homebrew/bin/brew shellenv)\"\n</code></pre> <ul> <li>Verify:</li> </ul> <pre><code>brew --version\nbrew doctor\n</code></pre>"},{"location":"tools/vscode/","title":"Visual Studio Code","text":"<p>Visual Studio Code is a lightweight editor with strong Git support and useful extensions.</p>"},{"location":"tools/vscode/#windows","title":"Windows","text":"<ul> <li>Install via Winget (recommended):</li> </ul> <pre><code>winget install --id Microsoft.VisualStudioCode -e\n</code></pre> <ul> <li>Verify:</li> </ul> <pre><code>code --version\n</code></pre> <ul> <li>If <code>code</code> is not in PATH, launch VS Code, press <code>Ctrl+Shift+P</code>, run \"Shell Command: Install 'code' command in PATH\", then rerun <code>code --version</code>.</li> </ul>"},{"location":"tools/vscode/#macos","title":"macOS","text":"<ul> <li>Install via Homebrew:</li> </ul> <pre><code>brew install --cask visual-studio-code\n</code></pre> <ul> <li>Verify:</li> </ul> <pre><code>code --version\n</code></pre> <ul> <li>If <code>code</code> is not found, open VS Code, press <code>Cmd+Shift+P</code>, and run \"Shell Command: Install 'code' command in PATH\".</li> </ul>"},{"location":"tools/vscode/#linux-debianubuntu","title":"Linux (Debian/Ubuntu)","text":"<ul> <li>Install Microsoft\u2019s repo and package:</li> </ul> <pre><code>sudo apt update\nsudo apt install -y wget gpg\nwget -qO- https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor &gt; packages.microsoft.gpg\nsudo install -D -o root -g root -m 644 packages.microsoft.gpg /etc/apt/keyrings/packages.microsoft.gpg\necho \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/packages.microsoft.gpg] https://packages.microsoft.com/repos/code stable main\" | sudo tee /etc/apt/sources.list.d/vscode.list\nsudo apt update\nsudo apt install -y code\ncode --version\n</code></pre> <ul> <li>Clean up the downloaded key file if desired:</li> </ul> <pre><code>rm -f packages.microsoft.gpg\n</code></pre>"},{"location":"tools/vscode/#settings-sync-with-github","title":"Settings Sync with GitHub","text":"<p>I recommend signing into VS Code using your GitHub account as it will allow you to sync your editor settings and profiles so you can have a consistent experience across devices.</p>"},{"location":"tools/vscode/#recommended-settings-and-extensions","title":"Recommended Settings and Extensions","text":""},{"location":"tools/vscode/#settings","title":"Settings","text":"<p>These are a couple of settings I always encourage new users to configure.</p> <p>To access your settings, press <code>Ctrl+Shift+P</code> on Windows/Linux or <code>Cmd+Shift+P</code> on macOS, type \"Settings\", and select \"Preferences: Open Settings (UI)\".</p> <ul> <li>Enable format on save:</li> <li>search \"format on save\"</li> <li>Disable folder compaction:</li> <li>search \"compact folders\"</li> <li>Disable file preview:</li> <li>search \"workbench editor preview\"</li> </ul>"},{"location":"tools/vscode/#extensions","title":"Extensions","text":"<p>VS Code has a huge amount of useful extensions. I've listed some of my recommended extensions below:</p> <ul> <li>Bash IDE (macOS/Linux, bash language server)</li> <li>Powershell (Windows, powershell language server)</li> <li>Error Lens (nice error messages)</li> <li>markdownlint (formatting for Markdown)</li> <li>Prettier - Code formatter (formatter for many filetypes)</li> <li>Puppet (for Puppet modules)</li> <li>Python (Python support)</li> <li>Ruby LSP (Ruby support for working with Puppet)</li> <li>YAML (the one from Red Hat, use for YAML support)</li> </ul>"},{"location":"tools/windows-terminal/","title":"Windows Terminal","text":"<p>Windows Terminal is a modern, tabbed terminal for Windows that handles PowerShell, Command Prompt, and WSL in one app. It supports Unicode, GPU-accelerated text rendering, and custom themes\u2014everything the legacy console lacks.</p>"},{"location":"tools/windows-terminal/#installation","title":"Installation","text":"<p>Option 1: Microsoft Store (recommended\u2014auto-updates)</p> <p>Open the Microsoft Store, search for \"Windows Terminal,\" and install.</p> <p>Option 2: WinGet</p> <pre><code>winget install --id Microsoft.WindowsTerminal -e\n</code></pre>"},{"location":"tools/windows-terminal/#verify-installation","title":"Verify Installation","text":"<p>Launch Windows Terminal from the Start menu. You should see a tabbed interface with PowerShell as the default.</p> <p>Check the version:</p> <pre><code>wt -v\n</code></pre>"},{"location":"tools/windows-terminal/#set-wsl-as-default-profile","title":"Set WSL as Default Profile","text":"<p>If you're using WSL for development, make it your default so new tabs open directly into Linux.</p> <ol> <li>Open Windows Terminal</li> <li>Press <code>Ctrl+,</code> to open Settings (or click the dropdown arrow \u2192 Settings)</li> <li>Under Startup, find Default profile</li> <li>Select Ubuntu (or your WSL distro) from the dropdown</li> <li>Click Save</li> </ol> <p>New tabs and windows now open in WSL by default. You can still open PowerShell or CMD tabs from the dropdown menu.</p>"},{"location":"tools/windows-terminal/#recommended-settings","title":"Recommended Settings","text":"<p>Open Settings (<code>Ctrl+,</code>) and consider these tweaks:</p> Setting Where Recommendation Default profile Startup Ubuntu (WSL) if you use Linux primarily Copy on select Interaction Enable\u2014highlight text to copy, right-click to paste Font Profiles \u2192 Defaults \u2192 Appearance Cascadia Code or Cascadia Mono (built-in, ligature support) Color scheme Profiles \u2192 Defaults \u2192 Appearance One Half Dark is readable; pick what works for you"},{"location":"tools/windows-terminal/#tips","title":"Tips","text":"<ul> <li>Split panes: <code>Alt+Shift+D</code> splits the current tab. Useful for running a command while watching logs.</li> <li>New tab with specific profile: <code>Ctrl+Shift+1</code> opens your default, <code>Ctrl+Shift+2</code> opens the second profile, etc.</li> <li>Zoom: <code>Ctrl+=</code> and <code>Ctrl+-</code> adjust font size on the fly.</li> </ul>"},{"location":"tools/wsl/","title":"Windows Subsystem for Linux (WSL)","text":"<p>WSL lets you run a full Linux environment directly on Windows\u2014no virtual machine, no dual-boot. You get a real Linux shell, real Linux tools, and real Linux package managers, all integrated with your Windows filesystem.</p>"},{"location":"tools/wsl/#why-use-wsl-for-development","title":"Why Use WSL for Development?","text":"<p>Most servers, containers, and CI/CD pipelines run Linux. When you develop on Windows but deploy to Linux, you're constantly fighting small differences: path separators, line endings, case sensitivity, shell syntax, missing tools.</p> <p>WSL eliminates this friction:</p> <ul> <li>Same tools as production. Use the same shell, package manager, and utilities you'll find on your servers. No more \"works on my machine\" because your machine is Linux.</li> <li>Native performance. WSL 2 runs a real Linux kernel. File operations, compilation, and container workloads run at near-native speed.</li> <li>Seamless integration. Access Windows files from Linux (<code>/mnt/c/</code>), run Linux commands from PowerShell, and use VS Code's Remote-WSL extension to edit Linux files with full IDE support.</li> <li>Better tooling support. Many development tools (Docker, Kubernetes, Terraform, Ansible, Puppet) are Linux-first. Documentation, tutorials, and Stack Overflow answers assume Linux. Stop translating\u2014just use Linux.</li> </ul> <p>If you're doing infrastructure work, writing scripts, or working with containers, WSL is the path of least resistance on Windows.</p>"},{"location":"tools/wsl/#installation","title":"Installation","text":""},{"location":"tools/wsl/#requirements","title":"Requirements","text":"<ul> <li>Windows 10 version 2004+ (Build 19041+) or Windows 11</li> <li>Virtualization enabled in BIOS (usually on by default)</li> </ul>"},{"location":"tools/wsl/#install-wsl","title":"Install WSL","text":"<p>Open PowerShell as Administrator and run:</p> <pre><code>wsl --install\n</code></pre> <p>This installs WSL 2 with Ubuntu as the default distribution. Restart when prompted.</p> <p>After restart, Ubuntu will launch automatically to complete setup. Create a username and password\u2014this is your Linux user, separate from your Windows account.</p>"},{"location":"tools/wsl/#verify-installation","title":"Verify Installation","text":"<p>Open a new PowerShell window:</p> <pre><code>wsl --version\n</code></pre> <p>You should see WSL version 2.x.x and a kernel version.</p> <p>Launch your Linux environment:</p> <pre><code>wsl\n</code></pre> <p>You're now in a bash shell. Run <code>uname -a</code> to confirm you're in Linux.</p>"},{"location":"tools/wsl/#basic-configuration","title":"Basic Configuration","text":""},{"location":"tools/wsl/#update-packages","title":"Update Packages","text":"<p>First thing after install\u2014update your package list:</p> <pre><code>sudo apt update &amp;&amp; sudo apt upgrade -y\n</code></pre>"},{"location":"tools/wsl/#install-common-tools","title":"Install Common Tools","text":"<pre><code>sudo apt install -y git curl wget unzip\n</code></pre>"},{"location":"tools/wsl/#access-windows-files","title":"Access Windows Files","text":"<p>Your Windows drives are mounted under <code>/mnt/</code>:</p> <pre><code>cd /mnt/c/Users/YourName/Documents\nls\n</code></pre>"},{"location":"tools/wsl/#access-linux-files-from-windows","title":"Access Linux Files from Windows","text":"<p>Your Linux home directory is accessible from Windows Explorer:</p> <pre><code>\\\\wsl$\\Ubuntu\\home\\yourusername\n</code></pre> <p>Or open Explorer from the Linux terminal:</p> <pre><code>explorer.exe .\n</code></pre>"},{"location":"tools/wsl/#using-wsl-with-vs-code","title":"Using WSL with VS Code","text":"<p>Install the Remote - WSL extension in VS Code.</p> <p>Then from your Linux terminal, open any folder in VS Code:</p> <pre><code>code .\n</code></pre> <p>VS Code connects to WSL and runs extensions inside Linux. You get full IntelliSense, debugging, and terminal access\u2014all running in your Linux environment.</p>"},{"location":"tools/wsl/#tips","title":"Tips","text":"<ul> <li>Keep projects in Linux filesystem. Store code in <code>~/projects</code>, not <code>/mnt/c/</code>. File operations are significantly faster on the Linux filesystem.</li> <li>Use Windows Terminal. It handles WSL, PowerShell, and CMD in tabs with proper Unicode support. See Windows Terminal.</li> <li>One distro is usually enough. Ubuntu is the default and has the best support. You can install multiple distros, but you probably don't need to.</li> </ul>"}]}