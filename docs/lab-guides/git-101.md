# Git 101 Lab

## Prerequisites

| Tool | Why You Need It |
|------|-----------------|
| Terminal | You'll run all Git commands here. macOS/Linux: use the built-in terminal. Windows: use [WSL](../tools/wsl.md) or [Windows Terminal](../tools/windows-terminal.md). |
| [Git](../tools/git.md) | Must be installed and configured with your name and email |
| Text editor | You'll edit files in your cloned repository. Use whatever you're comfortable with: [Visual Studio Code](../tools/vscode.md), a [command-line editor](../tools/cli-editors.md), or any other editor. |

## Setup

- You've been assigned a number (1-40). Throughout this lab, replace `XX` with your zero-padded number (e.g., 5 → `05`)
- If you haven't already, configure Git with your name and email:

    ```bash
    git config --global user.name "Your Name"
    git config --global user.email "you@uoregon.edu"
    ```

!!! tip "A note about Git GUIs"
    Tools like VS Code, GitKraken, and GitHub Desktop have excellent Git integration and can make your daily workflow faster. In this lab, we're using the command line exclusively. This is intentional:

    - The CLI is available everywhere -- remote servers, CI pipelines, containers, and minimal environments where a GUI isn't an option
    - GUI tools abstract away what's actually happening, which makes troubleshooting harder when things go wrong
    - Understanding the underlying commands means you can use *any* tool confidently, because you know what it's doing under the hood
    - Error messages and documentation reference CLI commands, not GUI buttons

    Once you're comfortable with the commands, use whatever tool you prefer day-to-day.

## Part 1: Cloning a Repository

!!! note "Talk about: What is a repository?"
    - What a **repository** is -- a project folder with its full history tracked by Git
    - **Local vs. remote** repositories -- local lives on your machine, remote lives on a server (GitHub, GitLab)
    - What **cloning** does -- copies the remote repo to your machine and links the two together

1. **Clone your personal repo:**

    ```bash
    git clone URL/participantXX/myrepo.git
    ```

2. **Move into the repo directory:** `cd myrepo`
3. **Look around:**

    ```bash
    ls
    git status
    git log
    ```

    `git status` shows the current state of your working directory. `git log` shows the commit history. Right now everything should be clean.

## Part 2: Editing and Pushing a Change

!!! note "Talk about: The staging area"
    - The **staging area** (index) -- a holding zone between your edits and a commit
    - Why it exists -- gives you control over exactly what goes into each commit
    - The three-step workflow: edit → `git add` → `git commit`

1. **Edit an existing file** in the repo (e.g., `README.md`) and make a small change
2. **Check what changed:**

    ```bash
    git status
    git diff
    ```

    `git status` shows which files have been modified. `git diff` shows the actual line-by-line changes.

3. **Stage the file:**

    ```bash
    git add README.md
    ```

4. **Check the status again:** `git status`

    Notice the file moved from "Changes not staged" to "Changes to be committed."

5. **Commit the change:**

    ```bash
    git commit -m "Update README with my info"
    ```

6. **Push to the remote:**

    ```bash
    git push
    ```

!!! note "Talk about: The four places your code lives"
    - **Working directory** -- files on disk where you make edits
    - **Staging area** -- where `git add` places changes you want to commit
    - **Local repository** -- where `git commit` saves snapshots
    - **Remote repository** -- where `git push` sends commits for others to access

## Part 3: Adding a New File

!!! note "Talk about: Tracked vs. untracked files"
    - **Untracked files** -- new files Git sees but won't include in commits until you `git add` them
    - **Tracked files** -- files Git watches for changes after the initial `git add`
    - Editing a tracked file still requires `git add` to stage the new changes

1. **Create a new file:**

    ```bash
    echo "This server is managed by participantXX" > info.txt
    ```

2. **Check the status:** `git status`

    Notice the file shows up under "Untracked files."

3. **Stage, commit, and push:**

    ```bash
    git add info.txt
    git commit -m "Add info.txt with participant details"
    git push
    ```

4. **Verify the history:**

    ```bash
    git log
    ```

    You should see both of your commits.

!!! tip "Shortcut: `git commit -am`"
    Now that you understand the difference between tracked and untracked files, here's a shortcut: `git commit -am "message"` combines `git add` and `git commit` in one step. The `-a` flag automatically stages all modified **tracked** files. It will **not** pick up new untracked files -- you still need `git add` for those. This is handy for quick edits to existing files, but the explicit `git add` + `git commit` workflow gives you more control.

## Part 4: Ignoring Files with .gitignore

!!! note "Talk about: Why ignore files?"
    - Files that don't belong in version control -- secrets, logs, build artifacts, editor temp files
    - The security risk of accidentally committing passwords or API keys
    - `.gitignore` -- tells Git to pretend matching files don't exist
    - Pattern matching -- exact filenames (`secret.txt`) and globs (`*.log`)

1. **Create some files you wouldn't want to commit:**

    ```bash
    echo "my_password" > secret.txt
    echo "some log output" > debug.log
    ```

2. **Check the status:** `git status`

    Both files show up as untracked. Git would happily let you commit them.

3. **Create a `.gitignore` file:**

    ```bash
    echo "secret.txt" > .gitignore
    echo "*.log" >> .gitignore
    ```

4. **Check the status again:** `git status`

    `secret.txt` and `debug.log` are gone. Only `.gitignore` itself shows as untracked.

5. **Stage, commit, and push the `.gitignore`:**

    ```bash
    git add .gitignore
    git commit -m "Add .gitignore for secrets and log files"
    git push
    ```

## Part 5: Working with Others

!!! note "Talk about: Shared repositories and pulling"
    - **Shared repositories** -- multiple people push to the same remote repo
    - **`git pull`** -- fetches new commits from the remote and merges them into your local branch
    - Why you need to pull before pushing -- the remote may have commits you don't have yet
    - **Non-conflicting changes** -- Git can automatically merge changes to different files

1. **Clone your group repo** (groups are 1-5, 6-10, etc.):

    ```bash
    cd ~
    git clone URL/groupN/ourrepo.git
    cd ourrepo
    ```

2. **Create a file named after yourself** so it won't conflict with your groupmates:

    ```bash
    echo "Hello from participantXX" > participantXX.txt
    git add participantXX.txt
    git commit -m "Add participantXX file"
    git push
    ```

    If someone in your group pushed first, your push will be rejected. That's expected.

3. **Pull to get their changes, then push again:**

    ```bash
    git pull
    git push
    ```

4. **Once everyone in your group has pushed**, pull one more time and check the log:

    ```bash
    git pull
    ls
    git log
    ```

    You should see everyone's files and commits.

## Part 6: Resolving a Merge Conflict

!!! note "Talk about: What is a merge conflict?"
    - A **merge conflict** happens when two people change the same lines in the same file
    - Git can't decide which version to keep, so it asks you to resolve it
    - **Conflict markers** -- `<<<<<<<`, `=======`, `>>>>>>>` show both versions in the file
    - Resolving a conflict means editing the file to the final version you want, then committing

1. **Everyone in the group edits the same file.** Open `README.md` and add a line with your name.
2. **One person pushes first:**

    ```bash
    git add README.md
    git commit -m "Add my name to README"
    git push
    ```

3. **Everyone else pulls and gets a conflict:**

    ```bash
    git pull
    ```

    You'll see a message about a merge conflict in `README.md`.

4. **Open `README.md`** and look for the conflict markers:

    ```
    <<<<<<< HEAD
    your changes
    =======
    their changes
    >>>>>>> abc1234
    ```

5. **Edit the file** to keep both names (remove the conflict markers), then complete the merge:

    ```bash
    git add README.md
    git commit -m "Resolve merge conflict in README"
    git push
    ```

6. **Repeat** until everyone in the group has pushed their resolved version

## Recap

- `git clone` creates a local copy of a remote repository
- `git status` and `git diff` show what's changed in your working directory
- `git add` stages changes for the next commit
- `git commit` saves a snapshot of staged changes with a message
- `git push` sends your commits to the remote repository
- `.gitignore` tells Git which files to exclude from tracking
- `git pull` fetches and merges changes from the remote
- **Merge conflicts** happen when two people change the same lines; Git asks you to resolve them
- The core workflow is: **edit → stage → commit → push** (and **pull** when working with others)

---

## Instructor Resources

### Server Requirements

| Requirement | Details |
|-------------|---------|
| Git remote | A Git server accessible to all participants (URL TBD) |
| User repositories | `participantXX/myrepo` created for each participant (1-40) with at least a `README.md` |
| Group repositories | `groupN/ourrepo` created for each group (1-8) with at least a `README.md` |
| Authentication | Participants must be able to clone and push (credentials or SSH keys pre-configured) |

### Finished State

Each participant's `myrepo` should have three new commits:

1. An edit to `README.md`
2. A new `info.txt` file
3. A `.gitignore` ignoring `secret.txt` and `*.log`

Each group's `ourrepo` should have:

1. One `participantXX.txt` file per group member
2. A `README.md` with every group member's name (with resolved merge conflicts)
